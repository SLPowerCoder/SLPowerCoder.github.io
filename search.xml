<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Block深入理解]]></title>
      <url>https://slpowercoder.github.io/2017/03/14/block/</url>
      <content type="html"><![CDATA[<h2 id="block-你应该了解的知识"><a href="#block-你应该了解的知识" class="headerlink" title="block 你应该了解的知识"></a>block 你应该了解的知识</h2><p>为什么不把本部分放到本质部分的下面呢，我以为实用为大，还是先把block的使用及其注意点写在前面吧。</p>
<p>1、为了方便声明block类型的变量，我们一般用typedef <code>typedef void (^Block)(void)</code>给block类型起个别名，这样我们就可以直接按如下方式声明block变量了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef void (^Block)(void);</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">//这样声明</div><div class="line">Block block = ^&#123;&#125;;</div><div class="line">//而不是这样</div><div class="line">//void(^block)(void)=^&#123;&#125;;</div><div class="line"></div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、在非ARC情况下，定义块的时候（无论是全局块还是局部块），其所占的内存区域是分配在栈中的。如下声明了一个block，如下面的代码就有危险，在条件语句实现的两个block都分配在栈内存中，于是这两个块只在对应的条件语句范围内有效，这样写的代码可以编译，但是运行起来却是时而对时儿错，若编译器未复写待执行的块，则程序正常运行，若复写则程序奔溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void (^block)();</div><div class="line">if(/*some condition*/)&#123;</div><div class="line">block = ^&#123;</div><div class="line">NSLog(@&quot;Block A&quot;);</div><div class="line">&#125;;</div><div class="line">&#125;else&#123;</div><div class="line">block = ^&#123;</div><div class="line">NSLog(@&quot;Block B&quot;);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">block();</div></pre></td></tr></table></figure>
<p>应该按这样的姿势写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void (^block)();</div><div class="line">if(/*some condition*/)&#123;</div><div class="line">block = [^&#123;</div><div class="line">NSLog(@&quot;Block A&quot;);</div><div class="line">&#125; copy];</div><div class="line">&#125;else&#123;</div><div class="line">block = [^&#123;</div><div class="line">NSLog(@&quot;Block B&quot;);</div><div class="line">&#125; copy];</div><div class="line">&#125;</div><div class="line">block();</div></pre></td></tr></table></figure>
<p>3、同理2，将block声明为属性的时候，要用copy，还要注意如果你不确定你生命的这个block属性会不会被其他线程修改，你就用atomic加个原子锁，这样就线程安全了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (copy) Block block; //属性默认就是atomic</div></pre></td></tr></table></figure>
<p>4、调用block的时候，有些童鞋的姿势不太对，假如我声明了一个block属性，正确调用姿势如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Block block  = self.block;</div><div class="line">if(block)&#123;</div><div class="line">block();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大部分童鞋会按下面这样写，那些连判断都不做的童鞋我就不批评你了，回去面壁去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if(self.block)&#123;</div><div class="line"></div><div class="line">//我是其他线程，我要这里要捣乱</div><div class="line"></div><div class="line">block();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的写法为什么不妥呢，因为即使self.block当时存在，如果另一个线程在该线程执行到我注释的那一行的时候把block置空了咋办，你再调用是不是就得到了一个完美的闪退，但是我如果把self.block 赋值给了一个局部变量的话，其他线程修改的是self.block而修改不了这个零时变量，所以上面的那种姿势不太稳妥。如果你看过AF的源码你就会发现，歪果仁就是按着我说的上面的正确姿势写的。</p>
<p>5、为什么用了__block就可以修改所截获的变量了？</p>
<p>因为block的特性，编译器不允许在block内直接修改所捕获的变量，但是我们可以修改<code>__block</code>修饰的自动变量，因为用<code>__block</code>修饰过之后，原先存储在栈中的变量就变成了存在堆中了，查看用clang过后的cpp文件你会发现在block中多了一个与该变量同名的<code>__Block_byref_i_0</code>结构体的指针变量，其中包含了存储在堆中的那个变量，可以通过结构体指针变量来直接更改变量的值，而没有用<code>__block</code>修饰的变量，block会把截获的变量copy为自己的一个变量。</p>
<p>6、避免循环引用，如果你把一个block声明成了对象的一个属性，那么该对象就会持有这个block，如果在该对象中要实现block属性的话，用到self的时候要用__weak修饰过的，不然会循环引用。</p>
<p>7、block的存储位置，栈、堆、全局数据区（强调一下如非特殊说明，block都是函数中实现）<br>block是否截获外围变量会影响他的存储区域的。</p>
<p>7.1 下图是ARC模式下执行的代码<br><img src="http://upload-images.jianshu.io/upload_images/1229960-46005086cdd8bc09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="ARC下的block.png"><br>7.2 下图是非ARC模式下执行的代码<br><img src="http://upload-images.jianshu.io/upload_images/1229960-5c079f6944335315.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="MRC下的block.png"></p>
<p>解释一下上面的结果，学过C的都知道，malloc是分配到堆中了，global是分配到全局数据区了。</p>
<p>7.3.1 MRC下此种写法Xcode会报错，但是如果不引用外围变量的话就没事，如果你仔细看7.1与7.2的介绍，你就知道原因了，不过我还是想说一下。因为在MRC情况下引入外围变量时，此种写法的block存在栈里面，而该函数的却返回了block，return标志着一个函数的结束，所以在return的时候block会被释放而报错，在MRC情况下不引入外围变量的话，此种写法的block存在全局数据区里，所以没问题。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1229960-925bdc8941a771d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="MRC下此种写法报错.png"><br>7.3.2 ARC下，无论引不引入外围变量，都没事，不引入返回的block存在全局数据区，引入的话存在堆中。就不截图了。</p>
<p>7.4 下面这种情况，ARC与MRC下block都存储在全局数据区，这种情况不常出现，一般我们都是在函数中来是实现block的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1229960-e11c0f8b876f7297.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="ARC与MRC下都存储在全局数据区.png"></p>
<p>7.5 总结（强调一下如非特殊说明，block都是函数中实现）：</p>
<p><strong>ARC模式下：</strong>不论你声明的是局部block还是全局block，它们只要不截获外围变量，它们都会存储在全局数据区的，如果截获外围变量，block就会存储在堆中。</p>
<p><strong>非ARC模式下：</strong>不论你声明的是局部block还是全局block，它们只要不截获外围变量，它们都会存储在全局数据区的，如果截获外围变量，block就会存储在堆中。</p>
<p><strong>两种模式下的差别：</strong>只要不截获外围变量block一律都存在全局数据区，只有截获了外围变量ARC和MRC才有所区别，而开发中往往我们的block都是后面这么一个情况，现在很少有人使用非ARC了吧，所以还是关注ARC的情况吧，即你只需要记住结论的第一条就好了。</p>
<h2 id="block-的本质"><a href="#block-的本质" class="headerlink" title="block 的本质"></a>block 的本质</h2><p>block其本质是一个struct，也可以说是一个含有自<a href="http://www.cnblogs.com/candyming/archive/2011/11/25/2262826.html" target="_blank" rel="external">动变量</a>的匿名函数，通过clang编译器转换成C++代码可以看出，执行<code>clang -rewrite-objc 要转换的OC文件</code>命令，可以在同级目录下获得一个.cpp文件，里面就是转换后的OC代码，下面我会分三种情况给出OC代码及其对应的cpp代码。</p>
<p>1、只是纯粹的在入口函数中定义了一个block，block中也没有引入外围变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">void(^block)(void)=^&#123;</div><div class="line">NSLog(@&quot;Block!!&quot;);</div><div class="line">&#125;;</div><div class="line">block();</div><div class="line"></div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是转换后的C++代码，为了方便观察，我把文件最下方的有关block的代码摘录如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//block的结构体</div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">//block的实现</div><div class="line">struct __block_impl impl;</div><div class="line">//block的描述（包含block的大小以及copy，dispose等）</div><div class="line">struct __main_block_desc_0* Desc;</div><div class="line">//block的构造函数，对block结构体成员变量的初始化</div><div class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">impl.Flags = flags;</div><div class="line">impl.FuncPtr = fp;</div><div class="line">Desc = desc;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//block内的代码实现部分</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1q_hr0kg_v15rj7ry_618ljfldr0000gn_T_hellow_a5b27a_mi_0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//block的描述，包含block的大小以及copy，dispose</div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">size_t reserved;</div><div class="line">size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line">//OC中的main函数</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line"></div><div class="line">void(*block)(void)=((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、在入口函数中定义了一个block，并在block中引入外围整型变量i</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">//自动变量i</div><div class="line">int i = 10;</div><div class="line">void(^block)(void)=^&#123;</div><div class="line"></div><div class="line">NSLog(@&quot;Block!!---%d&quot;,i);</div><div class="line">&#125;;</div><div class="line">block();</div><div class="line"></div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换后的cpp代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">struct __block_impl impl;</div><div class="line">struct __main_block_desc_0* Desc;</div><div class="line">//这是block捕获的变量</div><div class="line">int i; </div><div class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) &#123;</div><div class="line">impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">impl.Flags = flags;</div><div class="line">impl.FuncPtr = fp;</div><div class="line">Desc = desc;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">int i = __cself-&gt;i; // bound by copy</div><div class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1q_hr0kg_v15rj7ry_618ljfldr0000gn_T_main_1b12e5_mi_0,i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">size_t reserved;</div><div class="line">size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">int i = 10;</div><div class="line">void(*block)(void)=((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i));</div><div class="line">((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line"></div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、在入口函数中定义了一个block，并在block中引入外围整型变量i，并且i用__block修饰</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">__block int i = 10;</div><div class="line">void(^block)(void)=^&#123;</div><div class="line">i += 1;</div><div class="line">NSLog(@&quot;Block!!---%d&quot;,i);</div><div class="line">&#125;;</div><div class="line">block();</div><div class="line"></div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换后的cpp代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">//存储block截获的外围变量的一个结构体</div><div class="line">struct __Block_byref_i_0 &#123;</div><div class="line">void *__isa;</div><div class="line">__Block_byref_i_0 *__forwarding;</div><div class="line">int __flags;</div><div class="line">int __size;</div><div class="line">int i;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">struct __block_impl impl;</div><div class="line">struct __main_block_desc_0* Desc;</div><div class="line">//这是block捕获的变量</div><div class="line">__Block_byref_i_0 *i; // by ref</div><div class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) &#123;</div><div class="line">impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">impl.Flags = flags;</div><div class="line">impl.FuncPtr = fp;</div><div class="line">Desc = desc;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">__Block_byref_i_0 *i = __cself-&gt;i; // bound by ref</div><div class="line"></div><div class="line">(i-&gt;__forwarding-&gt;i) += 1;</div><div class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1q_hr0kg_v15rj7ry_618ljfldr0000gn_T_main_10e8d1_mi_0,(i-&gt;__forwarding-&gt;i));</div><div class="line">&#125;</div><div class="line"></div><div class="line">//下面两个指针函数是__main_block_desc_0结构体中的函数指针的实现，前者是要保留block截获的对象，后者则将之释放</div><div class="line"></div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">//block的描述</div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">size_t reserved;</div><div class="line">size_t Block_size;</div><div class="line">void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line"></div><div class="line">//主函数</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">__attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 10&#125;;</div><div class="line">void(*block)(void)=((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344));</div><div class="line">((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line"></div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一种和第二种比较可知，当block截获外围变量时，block会把截获的变量注册成为自己的成员变量，这也是为什么block不能直接修改截获的变量的原因，因为在block内操作的外围变量其实是block的同名的成员变量。</p>
<p>第一种和第三种比较可知，当block截获外围变量时，block会把截获的变量封装成<code>__Block_byref_i_0</code>结构体，并把结构体指针变量注册为自己的成员变量。</p>
<p>被<code>__block</code>修饰的外围变量会变成堆变量，这样这个外围变量就不会随函数的结束而被释放了，<code>__Block_byref_i_0</code>结构体中有一个指向原来外围变量的指针，通过这个指针是可以修改原来的外围变量的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS音频的播放以及录制]]></title>
      <url>https://slpowercoder.github.io/2017/03/10/iOS%E9%9F%B3%E9%A2%91%E7%9A%84%E6%92%AD%E6%94%BE%E4%BB%A5%E5%8F%8A%E5%BD%95%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>iOS中的音频包括两种类型，一种是时间比较短无需监听播放时间等属性的音效，一种是时间比较长的音乐</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS 深拷贝和浅拷贝]]></title>
      <url>https://slpowercoder.github.io/2017/02/11/iOS%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<p><strong>浅拷贝</strong>只是增加了一个对被引用对象的一个指向，拷贝出的对象与原对象共用一块内存区域。<br>retain：只是retainCount加一，实际上还是共用一块内存<br>copy：不论拷贝的是不是集合对象，只要被拷贝的对象是不可变的，那就是浅拷贝，仅仅retainCount加一</p>
<p><strong>深拷贝</strong>会分配出一块内存，然后将引用的内容拷贝进去，也就是说拷贝出来的对象与原对象是独立的。<br>copy：拷贝可变对象则是深拷贝<br>mutableCopy：不论被拷贝的是不是集合对象，是可变的还是不可变的，都是深拷贝</p>
<p><strong>注意：</strong>如果mutableCopy的是集合对象，深拷贝的是该集合对象，不是指该集合对象里面的元素，称之为<strong>单层深拷贝</strong>，对于集合对象内的元素依然是指针拷贝</p>
<p><strong>总结</strong><br>copy：只要copy的是<strong>不可变</strong>对象，都是浅拷贝，copy<strong>可变集合</strong>象则是单层深拷贝，拷贝<strong>可变非集合</strong>对象则是深拷贝<br>mutableCopy：拷贝<strong>集合</strong>象则是单层深拷贝，拷贝<strong>非集</strong>合对象则是深拷贝</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C 消息转发机制]]></title>
      <url>https://slpowercoder.github.io/2017/02/11/Objective-C%20%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>一图胜千言，习惯性的先来一张图以便对消息转发有个整体的把握</p>
<h3 id="运行时系统库方法查询流程图"><a href="#运行时系统库方法查询流程图" class="headerlink" title="运行时系统库方法查询流程图"></a>运行时系统库方法查询流程图</h3><p><img src="http://upload-images.jianshu.io/upload_images/1229960-edd81dfe76dacf77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行时系统库方法查询"></p>
<blockquote>
<p>对于对象无法处理的消息，如果不做转发处理的话，程序最终会调用NSObjective的doesNotRecognizeSelector:消息将程序crash掉。</p>
</blockquote>
<h3 id="Objective-C提供了两种消息转发选项"><a href="#Objective-C提供了两种消息转发选项" class="headerlink" title="Objective-C提供了两种消息转发选项"></a>Objective-C提供了两种消息转发选项</h3><ul>
<li>快速转发：NSObject类的子类A可以通过重写NSObject类的forwardingTargetForSelector:方法，将A的实例无法识别的消息转发给目标对象B，从而实现快速转发。<em>该技巧就像是将对象的实现代码与转发对象合并到一起。这类似于实现的多继承行为。如果你有一个定了对象 能够消化哪些消息的目标类，这个技巧可以取得很好的效果</em></li>
<li>标准（完整）转发：NSObject类的子类A可以通过重写NSObject类的forwardInvocation:方法，实现标准转发。标准转发巧可以通过methodSignatureForSelector：方法获取一个methodsignature对象最终被封为NSInvocation对象传递给forwardInvocation:方法（注意如果methodSignatureForSelector：方法返回一个nil，程序会crash）从该对象能获取消息的全部内容（包含目标，方法名，和参数）。</li>
</ul>
<p>如果你拥有了一个定义了对象能够消化哪些消息的目标类，快速转发可以取得很好的效果。如果你没有这样目标类或想要执行其他处理过程（如记录日志并‘吞下’消息），就应该使用完整转发。</p>
<h3 id="写了一大推字感觉很抽象，下面来点干货"><a href="#写了一大推字感觉很抽象，下面来点干货" class="headerlink" title="写了一大推字感觉很抽象，下面来点干货"></a>写了一大推字感觉很抽象，下面来点干货</h3><p>下面我要把Test实例的logName消息转发给Target实例，代码如下<br>Test头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  Test.h</div><div class="line">//  ForwardMsg</div><div class="line">//</div><div class="line">//  Created by 孙磊 on 2017/2/25.</div><div class="line">//  Copyright © 2017年 孙磊. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Test : NSObject</div><div class="line"></div><div class="line">-(void)logName;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>Test实现文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  Test.m</div><div class="line">//  ForwardMsg</div><div class="line">//</div><div class="line">//  Created by 孙磊 on 2017/2/25.</div><div class="line">//  Copyright © 2017年 孙磊. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;Test.h&quot;</div><div class="line">#import &quot;Target.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation Test&#123;</div><div class="line">    Target *mTarget;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        </div><div class="line">        //创建目标对象</div><div class="line">        mTarget = [Target new];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if 0</div><div class="line">//当一个对象无法识别消息后，会执行resolveInstanceMethod或者resolveClassMethod方法</div><div class="line">//如果不想进行消息转发，可以在此方法中动态添加消息来做处理</div><div class="line">//如果不重写此方法或者此方法返回NO，系统会执行forwardingTargetForSelector进行快速转发</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    if(sel == @selector(logName))&#123;</div><div class="line">        //第四个参数详解地址  https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html</div><div class="line">        //v代表返回类型为void</div><div class="line">        //@代表一个对象</div><div class="line">        //:代表一个selector</div><div class="line">        //因为OC中的每个方法都有默认的两个参数sel 和 selector，所以一般都是v@:</div><div class="line">        class_addMethod([self class],sel,(IMP)dynamicMethodIMP,&quot;v@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//万年备胎</div><div class="line">void dynamicMethodIMP(id self, SEL _cmd)</div><div class="line">&#123;</div><div class="line">    //对无法识别的消息做处理</div><div class="line">    NSLog(@&quot;该对象无法识别 %@ 方法------%s&quot;, NSStringFromSelector(_cmd),__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#else </div><div class="line"></div><div class="line">/***************==========1、快速消息转发，快速转发只可以获取到方法签名==========*******************/</div><div class="line"></div><div class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">    if ([mTarget respondsToSelector:aSelector]) &#123;</div><div class="line">        //目标对象有对应的处理方法，则就会快速消息转发，不会再执行完整消息转发了</div><div class="line">        return mTarget;</div><div class="line">    &#125;</div><div class="line">    //目标对象也没有对应的方法，此时系统会执行forwardInvocation进行完整消息转发</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/***********=============2、标准（完整）消息转发，完整消息转发，可以获取方法签名，参数等详细信息==========*********/</div><div class="line"></div><div class="line">//返回一个完整的方法签名，提供给forwardInvocation以便完整转发消息</div><div class="line">-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;</div><div class="line">    </div><div class="line">    NSMethodSignature* signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    </div><div class="line">     if (!signature)</div><div class="line">        signature = [mTarget methodSignatureForSelector:aSelector];</div><div class="line"></div><div class="line">     return signature;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)forwardInvocation:(NSInvocation *)anInvocation&#123;</div><div class="line">    NSLog(@&quot;%s-----完整消息转发------&quot;,__func__);</div><div class="line">    SEL invSEL = anInvocation.selector;</div><div class="line">    if ([mTarget respondsToSelector:invSEL])&#123;</div><div class="line">        </div><div class="line">        //利用forwardInvocation方法来重新指定消息处理对象</div><div class="line">        [anInvocation invokeWithTarget:mTarget];</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        [self doesNotRecognizeSelector:invSEL];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>目标文件的头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  Target.h</div><div class="line">//  ForwardMsg</div><div class="line">//</div><div class="line">//  Created by 孙磊 on 2017/2/25.</div><div class="line">//  Copyright © 2017年 孙磊. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Target : NSObject</div><div class="line"></div><div class="line">-(void)logName;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>目标文件的实现文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  Target.m</div><div class="line">//  ForwardMsg</div><div class="line">//</div><div class="line">//  Created by 孙磊 on 2017/2/25.</div><div class="line">//  Copyright © 2017年 孙磊. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;Target.h&quot;</div><div class="line"></div><div class="line">@implementation Target</div><div class="line"></div><div class="line">-(void)logName&#123;</div><div class="line">NSLog(@&quot;我是备用方法---%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="external">推荐一个国外大大利用消息转发避免后台返回NSNull（后台有时候会返回<null>）而引起的奔溃问题，例如你需要一个字符串他却给你返回了一个“<null>”这样一个NSNull对象。用法很简单，直接把NullSafe.m拖到项目中即可，该文件会在运行时自动加载</null></null></a></p>
<p>扩展：简单说一下NULL，nil，Nil，NSNull的用处<br>NULL：用于普通类型，例如NSInteger<br>nil：用于OC对象（除了类这个对象）,给nil对象发送消息不会crash<br>Nil：用于Class类型对象的赋值（类是元类的实例，也是对象）<br>NSNull：用于OC对象的站位，一般会作为集合中的占位元素，给NSNull对象发送消息会crash的，后台给我们返回的<null>就是NSNull对象</null></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS中assign与weak，retain与strong的区别]]></title>
      <url>https://slpowercoder.github.io/2017/02/11/iOS%E4%B8%ADassign%E4%B8%8Eweak%EF%BC%8Cretain%E4%B8%8Estrong%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>以前在没有ARC的时候我们使用assign与retain来修饰属性，后来引入了更安全的weak和strong来修饰属性</p>
<h3 id="assign与weak"><a href="#assign与weak" class="headerlink" title="assign与weak"></a>assign与weak</h3><p>两者都是弱引用，assign通常用于普通类型属性（如int,NSInteger），还有代理属性的修饰，基本上来说两者是可以通用的。<br>只是后者比前者多了一个功能，后者会在引用的对象被释放的时候将该属性置为nil，而前者依然会指向原来的位置，这样就会变成野指针。在oc中你给你一个nil对象发送消息不会crash，但是给一个对象发送他不能解析的消息是会crash的，所以总的来说weak要比assign安全一些。<br>像delegate属性建议用weak修饰而不是assign。</p>
<h3 id="retain和strong"><a href="#retain和strong" class="headerlink" title="retain和strong"></a>retain和strong</h3><p>他俩都是强引用，除了某些情况下不一样，其他的时候也是可以通用的。</p>
<p>在修饰block属性的时候，相信大家都知道要用copy，<strong>对于一个没有引用外围变量（block外面的）的block是存储在堆里面的，但是大多数时候我们都会在block中引入外围变量，这样的话block就被存储在栈里面</strong>，如果不copy的话，他的生命周期会随着函数的结束而结束，copy之后会放在堆里面，延长block的生命周期。<br>strong在修饰block的时候就相当于copy，而retain修饰栈block的时候就相当于assign，这样block会出现提前被释放掉的危险。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS中为什么非要用runtime才能在分类中扩展属性呢]]></title>
      <url>https://slpowercoder.github.io/2017/02/11/iOS%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E8%A6%81%E7%94%A8runtime%E6%89%8D%E8%83%BD%E5%9C%A8%E5%88%86%E7%B1%BB%E4%B8%AD%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7%E5%91%A2/</url>
      <content type="html"><![CDATA[<p>想必大家都知道在分类中能扩展属性，而对于能不能扩展属性，能不能扩展成员变量是不是有点模糊，今天元宵节，我就清清嗓子说上两句吧</p>
<h5 id="论点"><a href="#论点" class="headerlink" title="论点"></a>论点</h5><p>1.分类中是能扩展属性的<br>2.分类是不能给一个类扩展成员变量的</p>
<h5 id="先唠唠嗑"><a href="#先唠唠嗑" class="headerlink" title="先唠唠嗑"></a>先唠唠嗑</h5><p>强调一下，分类不是类，它只是对类的一个扩展，没有ISA指针，我们知道我们可以通过runtime在不影响原来模块的情况下给模块扩展方法，有没有感觉这一句话好像也可以描述分类，<em>所以你可以认为分类是实现这一功能的捷径</em>，不然你觉得是用分类扩展方法容易还是用runtime来实现容易啊（正值年轻，说话有点冲~_~ !!）。</p>
<h5 id="论据"><a href="#论据" class="headerlink" title="论据"></a>论据</h5><p>先说说属性，属性是对成员变量的一个封装，当我们声明一个属性的时候，Xcode会给我们默认创建一个 <strong>_属性名</strong> 的成员变量，也会给我们自动创建getter和setter方法。当然我们也可以用@synthesize指定其关联的变量<br>例如给属性name指定其关联的变量<code>@synthesize name = xxx；self.name</code>其实是操作的实例变量xxx，而不是_name了。<br>窝草，扯远了，回归正传。。<br>所以我们要添加一个属相得有三样东西，setter、getter以及关联的成员变量。<br>在分类中Xcode不会为我们自动创建setter、getter方法，我们可以手动实现，但是如何把一个变量关联到属性上呢，直接声明一个全局变量然后不行吗，事实证明不太行，对于getter方法还好说，直接返回一个变量就行，可是setter方法却不行，因为你要找到该属性关联的变量你才能给人家赋值啊，怎么办？怎么办？？这只能用runtime的对象关联来实现了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">.m文件中</div><div class="line">// 定义关联的key</div><div class="line">static const char *key = &quot;name&quot;;</div><div class="line"></div><div class="line">@implementation NSObject (Property)</div><div class="line"></div><div class="line">- (NSString *)name</div><div class="line">&#123;</div><div class="line">  // 根据关联的key，获取关联的值。</div><div class="line">  return objc_getAssociatedObject(self, key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setName:(NSString *)name</div><div class="line">&#123;</div><div class="line">  // 参数一：目标对象</div><div class="line">  // 参数二：关联的key，可以通过这个key获取</div><div class="line">  // 参数三：关联的value</div><div class="line">  // 参数四：关联的策略</div><div class="line">  objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>看到这里你也许就会说，这TMD不是把变量给添加上去了吗？我表示默默一笑，如果你打印IVarList你就会发现并没有这个变量，只能打印出添加的属性。<br>其实<strong>对象关联</strong>只是关联上去了，并没有把变量添加进去，说了这么多这回你该信了吧。<br><strong><em>原因就是分类不是类，他没有ISA指针，下面是ISA指针，可以看出他本质上是一个结构体（只是换了个马甲被称之为Class类型，怕你迷糊，再说明白一点，ISA指针就是Class类型），通过ISA指针才能找指向变量的ivars，也就是说你都不知道变量的家，你怎么去给它生猴子啊，但是奇怪了，ISA指针里没有指向属性数组的指针，没有是对的，要不然这一段的解释就废了，可是讲真，属性指针在哪啊？？？有知道的小伙伴请告诉我一下 &gt;_&lt; !!!</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    const char *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div><div class="line">/* Use Class instead of `struct objc_class *` */</div></pre></td></tr></table></figure>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>分类中可以给一个对象（类也是对象）添加属性，但是不能添加成员变量，只能<strong>关联</strong>上去。<br><strong>注意：</strong>如果不信，你可以自己再打印一遍吧，会发现只能打印出添加的属性，打印不出变量。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[运行react native 官方例子出错的解决办法]]></title>
      <url>https://slpowercoder.github.io/2017/01/07/%E8%BF%90%E8%A1%8Creact%20native%20%E5%AE%98%E6%96%B9%E4%BE%8B%E5%AD%90%E5%87%BA%E9%94%99/</url>
      <content type="html"><![CDATA[<p>学习一样新的东西官网文档和官方源码例子无疑是最好的选择，所以今天clone了官方的例子，100多兆，如果网速不好的话会等待很长时间 ~_~!!，然后直接cd到根目录执行了npm install安装了依赖，可是安装的过程中出错了（也有可能安装成功了，但是运行失败了），估计例子上的版本跟我安装的rn版本不兼容吧。<br>我目前的RN版本是0.39，命令行的版本是react-native-cli:2.0.1</p>
<p>先上官方运行效果图：<br><img src="http://upload-images.jianshu.io/upload_images/1229960-edb9d9b477259960.gif?imageMogr2/auto-orient/strip" alt="官方效果图"></p>
<h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>情况一：如果npm install安装失败的话<br><br>1、git checkout 0.xx-stable切换到稳定的分支，我切换的是0.41-stable版本，安装运行成功。<br><br>2、npm install<br><br>3、找到Examples，里面有四个例子，可以用Xcode打开运行<br></p>
<p>情况二：npm install 安装成功，但运行失败<br><br>1、git checkout 0.xx-stable切换到稳定的分支<br><br>2、fm -rf node_modules &amp;&amp; npm install<br><br>3、找到Examples，里面有四个例子，可以用Xcode打开运行<br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[看了我这篇RN你就入门了]]></title>
      <url>https://slpowercoder.github.io/2016/12/30/%E4%B8%80%E5%90%8DiOSer%E5%AF%B9react-redux%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React认为每个组件都是一个个有限状态机，状态与UI是一一对应的。我们只需管理好APP的state就能控制UI的显示，我们可以在每个component类中来通过<code>this.state</code>和<code>this.setState</code>来管理组件的state，但是如果APP交互比较多比较复杂，或者说该组件的某一状态需要和其他组件共享的话，这种方式就有点复杂了。<br>有没有一种能统一管理APP状态的框架呢，这时候Redux就在我们的期盼中驾着七彩祥云降临人间了，她是一个用于统一管理APP 所有的state的一个的js框架，她不建议我们在component中直接操作state，而是交给redux的store中进行处理。后来又发现redux使用着也是不太方便啊，每次dispatch(action)的时候都需要store对象，最后redux的作者又专门为react native量身订做了一个react-redux，故事就这样开始了。</p>
<h2 id="redux的设计思想"><a href="#redux的设计思想" class="headerlink" title="redux的设计思想"></a>redux的设计思想</h2><p><code>（1）Web 应用是一个状态机，视图与状态是一一对应的。</code><br><code>（2）所有的状态，保存在一个对象里面，由其统一管理。</code><br><code>（3）状态在组件中是‘只读’的，要交给redux处理</code></p>
<h2 id="redux概念"><a href="#redux概念" class="headerlink" title="redux概念"></a>redux概念</h2><p>有图有真相，先来一张redux数据流图，让你有一个整体的把握<br><img src="http://upload-images.jianshu.io/upload_images/1229960-9cae53256b3bba52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redux flow"></p>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>一般是不允许用户直接操作类的state，而是通过触发消息来执行对应的操作来产生一个新的state，用户或后台服务器可以通过store.dispatch(action)来向store发送一个消息（消息至少一个标识该消息的字段type，还可以添加其他字段用于数据传送），store会在内部根据消息的类型type去reducer中执行相应的处理，这个消息我们就叫他为Action，Action本质上是一个JavaScript对象。</p>
<p>实际编码中一般会把整个应用的消息类型统一放在一个文件ActionTypes.js中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO = <span class="string">'ADD_TODO'</span></div></pre></td></tr></table></figure>
<p>Action的结构如下，各个字段的key的名字可以随意命名，但是类型的key一般都是type，数据类型最好为字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  type: ADD_TODO,</div><div class="line">  text: <span class="string">'Build my first Redux app'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>随着程序越来越大，你会发现一个组件中的action太多太乱了，所以我们也会把action按业务分类放在各个指定的文件中，但是又有一个问题，若果每个action的字段都有五六个，我们在如下写法岂不是太乱了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">store.dispatch(&#123;</div><div class="line">  type: ADD_TODO,</div><div class="line">  text: <span class="string">'Build my first Redux app'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>于是乎我们就想起来可以将action对象封装在函数中，这个函数返回一个action对象，这个返回一个action对象的函数我们就称之为ActionCreator，如下所示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> todo = ()=&gt; &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">	 	type: ADD_TODO,</div><div class="line">  		text: <span class="string">'Build my first Redux app'</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们直接store.dispatch(todo)就好了，看着是不是整洁多了啊</p>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>它是一个纯函数，要求有相同的输入（参数）就一定会有相同的输出，它会根据当前的state和action来进行逻辑处理返回一个新的state<br>参数一：当前的state对象<br>参数二：action对象<br>返回值：产生一个新的state对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; VisibilityFilters &#125; <span class="keyword">from</span> <span class="string">'./actions'</span></div><div class="line"><span class="comment">//初始state</span></div><div class="line"><span class="keyword">const</span> initialState = &#123;</div><div class="line">  visibilityFilter: VisibilityFilters.SHOW_ALL,</div><div class="line">  todos: []</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> SET_VISIBILITY_FILTER:</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">        visibilityFilter: action.filter</div><div class="line">      &#125;)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：reducer函数中一定不要去修改state，而是用Object.assign()函数生成一个新的state对象，如上所示</p>
<p><strong>combineReducers</strong>：随着应用变得复杂，把APP的所有状态都放在一个reducer中处理会造成reducer函数非常庞大，因此需要对 reducer 函数 进行拆分，拆分后的每一个子reducer独立负责管理 APP state 的一部分。combineReducers 辅助函数的作用是，把多个不同子reducer 函数合并成一个最终的根reducer ，最后将根 reducer 作为createStore的参数就可以创建store对象了。合并后的 reducer 可以调用各个子 reducer，并把它们的结果合并成一个 state 对象。state 对象的结构由传入的多个 reducer 的 key 决定。</p>
<p>最终，state 对象的结构会是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  reducer1: ...</div><div class="line">  reducer2: ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法如下所示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> Strolling <span class="keyword">from</span> <span class="string">'./strollingReducer'</span>;</div><div class="line"><span class="keyword">import</span> Foods <span class="keyword">from</span> <span class="string">'./foodsReducer'</span>;</div><div class="line"><span class="keyword">import</span> FoodsList <span class="keyword">from</span> <span class="string">'./foodsListReducer'</span>;</div><div class="line"><span class="keyword">import</span> FoodCompare <span class="keyword">from</span> <span class="string">'./foodCompareReducer'</span>;</div><div class="line"><span class="keyword">import</span> FoodInfo <span class="keyword">from</span> <span class="string">'./foodInfoReducer'</span>;</div><div class="line"><span class="keyword">import</span> Search <span class="keyword">from</span> <span class="string">'./searchReducer'</span>;</div><div class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./userReducer'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer = combineReducers(&#123;</div><div class="line">    Strolling,</div><div class="line">    Foods,</div><div class="line">    FoodsList,</div><div class="line">    FoodCompare,</div><div class="line">    FoodInfo,</div><div class="line">    Search,</div><div class="line">    User,</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// export default rootReducer = combineReducers(&#123;</span></div><div class="line"><span class="comment">//     Strolling:Strolling,</span></div><div class="line"><span class="comment">//     Foods:Foods,  </span></div><div class="line"><span class="comment">//     FoodsList:FoodsList,</span></div><div class="line"><span class="comment">//     FoodCompare:FoodCompare,</span></div><div class="line"><span class="comment">//     FoodInfo:FoodInfo,</span></div><div class="line"><span class="comment">//     Search:Search,</span></div><div class="line"><span class="comment">//     User:User,</span></div><div class="line"><span class="comment">// &#125;)</span></div><div class="line"> </div><div class="line"><span class="comment">// export default function rootReducer(state = &#123;&#125;,action)&#123;</span></div><div class="line"></div><div class="line"><span class="comment">//     return&#123;</span></div><div class="line"><span class="comment">//         Strolling: Strolling(state.Strolling,action),</span></div><div class="line"><span class="comment">//         Foods:Foods(state.Foods,action),</span></div><div class="line"><span class="comment">//         FoodsList:FoodsList(state.FoodsList,action),</span></div><div class="line"><span class="comment">//         FoodCompare:FoodCompare(state.FoodCompare,action),</span></div><div class="line"><span class="comment">//         FoodInfo:FoodInfo(state.FoodInfo,action),</span></div><div class="line"><span class="comment">//         Search:Search(state.Search,action),</span></div><div class="line"><span class="comment">//         User:User(state.User,action)</span></div><div class="line"><span class="comment">//     &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"></div><div class="line"><span class="comment">//以上三种方式是等价的,key可以设置也可以省略</span></div></pre></td></tr></table></figure>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>一个应用只有一个store，store 就是用来维持应用所有的 state 树 的一个对象。 改变 store 内 state 的惟一途径是对它 dispatch 一个 action，它有三个函数</p>
<ul>
<li><strong>getState()</strong><br>  返回应用当前的 state 树。</li>
<li><strong>dispatch(action)</strong><br>  分发 action。这是触发 state 变化的惟一途径。<br>  会使用当前 getState() 的结果和传入的 action 以同步方式的调用 store 的 reduce 函数。返回值会被作为下一个 state。从现在开始，这就成为了 getState() 的返回值，同时变化监听器(change listener)会被触发。</li>
<li><p><strong>subscribe(listener)</strong><br>  当state树发生变化的时候store会调用subscribe函数，我们可以传一个我们订制的函数作为参数来进行处理<br>  参数：一个函数<br>  返回值：返回一个解绑定函数</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//添加监听</span></div><div class="line"><span class="keyword">let</span> unsubscribe = store.subscribe(handleChange)</div><div class="line"><span class="comment">//解除监听</span></div><div class="line">unsubscribe()</div></pre></td></tr></table></figure>
</li>
<li><p><strong>replaceReducer(nextReducer)</strong><br> 替换 store 当前用来计算 state 的 reducer。<br> 这是一个高级 API。只有在你需要实现代码分隔，而且需要立即加载一些 reducer 的时候才可能会用到它。在实现 Redux 热加载机制的时候也可能会用到。</p>
</li>
</ul>
<h2 id="react-redux基础"><a href="#react-redux基础" class="headerlink" title="react-redux基础"></a>react-redux基础</h2><p>前言已经提到过react-redux的由来，这里在啰嗦一下，react-redux是redux作者专门为react native订制的，这样使用起来更方便，我们只需在我们的组件中通过属性props获取dispatch方法，就可以直接向store发送一个action，而不需要再获取store对象，通过store对象的dispatch方法发送。<br>react-redux有两宝，<strong>provider</strong>和<strong>connect</strong>，下面详细介绍一下。</p>
<h3 id="Provider："><a href="#Provider：" class="headerlink" title="Provider："></a>Provider：</h3><p>有一个store属性，我们要将应用的根标签放到Provider标签中，这样应用的所有标签就可以通过context来获取store对象了，但是我们一般不会通过此法来获取store对象，Provider是为了给connect函数使用的，这样才能通过connect函数的参数获取到store的state和dispatch了。</p>
<h3 id="connect-mapStateToProps-mapDispatchToProps-mergeProps-options"><a href="#connect-mapStateToProps-mapDispatchToProps-mergeProps-options" class="headerlink" title="connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])"></a>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</h3><p>参数一：[mapStateToProps(state, [ownProps]): stateProps] (Function)</p>
<blockquote>
<p>如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。如果你省略了这个参数，你的组件将不会监听 Redux store。如果指定了该回调函数中的第二个参数 ownProps，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，mapStateToProps 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。</p>
</blockquote>
<p>参数二：[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function):</p>
<blockquote>
<p>如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。如果传递的是一个函数，该函数将接收一个 dispatch 函数，然后由你来决定如何返回一个对象，这个对象通过 dispatch 函数与 action creator 以某种方式绑定在一起（提示：你也许会用到 Redux 的辅助函数 bindActionCreators()）。<code>如果你省略这个 mapDispatchToProps 参数，默认情况下，dispatch 会注入到你的组件 props 中。</code>如果指定了该回调函数中第二个参数 ownProps，该参数的值为传递到组件的 props，而且只要组件接收到新 props，mapDispatchToProps 也会被调用。</p>
</blockquote>
<p>参数三：[mergeProps(stateProps, dispatchProps, ownProps): props] (Function)</p>
<blockquote>
<p>如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的 props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。你也许可以用这个回调函数，根据组件的 props 来筛选部分的 state 数据，或者把 props 中的某个特定变量与 action creator 绑定在一起。如果你省略这个参数，默认情况下返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。<br>[options] (Object) 如果指定这个参数，可以定制 connector 的行为。</p>
</blockquote>
<p>参数四：[options] (Object) 如果指定这个参数，可以定制 connector 的行为。</p>
<blockquote>
<p>[pure = true] (Boolean): 如果为 true，connector 将执行 shouldComponentUpdate 并且浅对比 mergeProps 的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或 state 而只依赖于 props 和 Redux store 的 state。默认值为 true。<br>[withRef = false] (Boolean): 如果为 true，connector 会保存一个对被包装组件实例的引用，该引用通过 getWrappedInstance() 方法获得。默认值为 false。</p>
</blockquote>
<h2 id="redux-redux使用"><a href="#redux-redux使用" class="headerlink" title="redux-redux使用"></a>redux-redux使用</h2><p>上面说了provider和connect方法，下面是实用讲解</p>
<p>创建store对象的js文件</p>
<p>下面的代码里包括应用中间件redux-thunk，和创建store对象两步，<a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" target="_blank" rel="external">这里有更多关于中间件的详情</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</div><div class="line">import thunk from &apos;redux-thunk&apos;;</div><div class="line">import rootReducer from &apos;../reducers/rootRudcer&apos;;</div><div class="line">//使用thunk中间件</div><div class="line">let createStoreWithMiddleware = applyMiddleware(thunk)(createStore);</div><div class="line">//创建store对象，一个APP只有一个store对象</div><div class="line">let store = createStoreWithMiddleware(rootReducer);</div><div class="line">export default store;</div></pre></td></tr></table></figure>
<p>程序的入口文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</div><div class="line">import store from &apos;./store/store&apos;;</div><div class="line"></div><div class="line">import App from &apos;./containers/app&apos;;</div><div class="line"></div><div class="line">export default class Root extends React.Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">        	//将APP的根视图组件包含在provider标签中</div><div class="line">            &lt;Provider store = &#123;store&#125; &gt;</div><div class="line">                &lt;App /&gt;</div><div class="line">            &lt;/Provider&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在容器组件中，将redux和容器组件关联起来，这里是redux与组件关联的地方，大多数童鞋使用redux最迷惑的地方估计就在这一块了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line">import &#123;connect&#125; from &apos;react-redux&apos;;</div><div class="line">import Brand from &apos;../Components/Brand&apos;;</div><div class="line"></div><div class="line">//BrandContainer容器组件</div><div class="line">class BrandContainer extends React.Component &#123;</div><div class="line">    </div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">        	//把容器组件的属性传递给UI组件</div><div class="line">            &lt;Brand &#123;...this.props&#125; /&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default connect((state) =&gt; &#123;</div><div class="line">    const &#123; BrandReducer &#125; = state;</div><div class="line">    return &#123;</div><div class="line">        BrandReducer</div><div class="line">    &#125;</div><div class="line">&#125;)(BrandContainer);</div></pre></td></tr></table></figure>
<p>这样UI组件Brand中就可以通过属性获取dispatch方法以及处理后的最新state了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const &#123;dispatch, BrandReducer&#125; = this.props;</div></pre></td></tr></table></figure>
<p>下面来解释一下上面的代码</p>
<p>将当前的BrandContainer组件关联起来，上面介绍了store中的state对象的结构会是这样的：</p>
<p>{<br><br>  reducer1: …<br><br>  reducer2: …<br><br>}</p>
<p>所以可以通过解构的方式，获取对应模块的state，如下面的const { BrandReducer } = state;</p>
<p>下面这一块代码的作用就是将store中state传递给关联的容器组件中，当store中的state发生变化的时候，connect的第一参数mapStateToProps回调函数就会被调用，并且将该回调函数的返回值映射成其关联组件的一个属性，这样容器组件的属性就会发生变化，而UI组件又通过{…this.props}将容器组件的属性传递给了UI组件，所以UI组件的属性也会发生变化，我们知道属性的变化会导致UI组件重新render。好了，我们就能知道为什么我们在UI组件中dispatch一个action后UI组件能更新了，因为UI组件的属性发生变化导致RN重绘了UI。</p>
<h2 id="react-native-组件的生命周期"><a href="#react-native-组件的生命周期" class="headerlink" title="react native 组件的生命周期"></a>react native 组件的生命周期</h2><h3 id="弄明白了这个图我认为你就能基本掌握RN了"><a href="#弄明白了这个图我认为你就能基本掌握RN了" class="headerlink" title="弄明白了这个图我认为你就能基本掌握RN了"></a>弄明白了这个图我认为你就能基本掌握RN了</h3><p><img src="http://7xqg0d.com1.z0.glb.clouddn.com/hexoBlog/react-native%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F.PNG" alt="redux flow"></p>
<h3 id="项目的推荐目录"><a href="#项目的推荐目录" class="headerlink" title="项目的推荐目录"></a>项目的推荐目录</h3><p><img src="http://7xqg0d.com1.z0.glb.clouddn.com/blog/react%20native%E7%9B%AE%E5%BD%95%E7%A4%BA%E4%BE%8B.png" alt="项目的推荐目录"></p>
<h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p>暂时不说了，苹果粑粑这两天不高兴了，凡是热更新的APP不能上架，已上线的APP也应该收到了一份批评邮件了。<br><img src="http://7xqg0d.com1.z0.glb.clouddn.com/blog/deny%20hotspatch.JPG" alt="你尽管hot patch吧"></p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="http://www.tuicool.com/articles/MrmYN36" target="_blank" rel="external">React 实践心得：react-redux 之 connect 方法详解</a><br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="external">Redux 入门教程（一）：基本用法</a><br><a href="http://www.redux.org.cn/" target="_blank" rel="external">redux中文文档</a></p>
<p><em>注：部分图片来源于互联网</em></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS小知识]]></title>
      <url>https://slpowercoder.github.io/2016/09/02/iOS%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>原文<a href="https://slpowercoder.github.io/">https://slpowercoder.github.io/</a></p>
<ol>
<li><p>去掉按钮的高亮黑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[funcImgBtn setAdjustsImageWhenHighlighted:NO];</div></pre></td></tr></table></figure>
</li>
<li><p>设置视图属性防止背景图片变形<br>关于UIViewContentMode的详解<br><a href="http://blog.csdn.net/iunion/article/details/7494511" target="_blank" rel="external">http://blog.csdn.net/iunion/article/details/7494511</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//对于UIButton需要设置button中的imageView的contentMode属性</div><div class="line">button.imageView.contentMode = UIViewContentModeScaleAspectFill;</div><div class="line">//</div><div class="line">视图.contentMode = UIViewContentModeScaleAspectFill;</div><div class="line">视图.clipsToBounds = YES;</div></pre></td></tr></table></figure>
</li>
<li><p>当一个页面有多个scrollView（或继承自scrollVIew）的时候，点击状态栏不会回到顶部，可以将非当前显示页的scrollVIew. scrollToTop设置为NO。</p>
</li>
<li><p>去掉在UITableViewStylePlain 样式的时候多余的默认cell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_tableView.tableFooterView = [[UIView alloc]init];</div></pre></td></tr></table></figure>
</li>
<li><p>去掉在UITableViewStyleGrouped 样式的时候默认的组脚高度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section&#123;</div><div class="line">return 0.001; //越小越好，不能设置为0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>自定义导航栏的返回按钮而造成返回手势的失效的解决办法，对于最顶层的VC我们需要设置enabled = NO，因为最外面一层是不需要该手势的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.navigationController.interactivePopGestureRecognizer.delegate = self;</div><div class="line">self.navigationController.interactivePopGestureRecognizer.enabled = YES;</div></pre></td></tr></table></figure>
</li>
<li><p>根据十六进制色值返回一个UIColor对象的宏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define USERCOLOR(string) [UIColor colorWithRed:((float)((string &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((string &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(string &amp; 0xFF))/255.0 alpha:1.0]</div></pre></td></tr></table></figure>
</li>
<li><p>控制屏幕是否锁屏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//值为yes的时候可以防止屏幕黑屏，注意在程序结束点时候要设置为no</div><div class="line">[[UIApplication sharedApplication] setIdleTimerDisabled:YES];</div></pre></td></tr></table></figure>
</li>
<li><p>防止自定义导航栏返回按钮时，返回手势失效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.navigationController.interactivePopGestureRecognizer.enabled = YES;</div></pre></td></tr></table></figure>
</li>
<li><p>打印函数，可以打印所在的函数，行数，以及你要打印的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define DLog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__);</div></pre></td></tr></table></figure>
</li>
<li><p>UISwitch的大小直接设置frame是没有用的，可以通过CGAffineTransformMakeScale缩放来设置</p>
</li>
<li><p>load和initialize</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//程序在加载类文件时候会调用load，无论实现该方法的类有没有被引用（只要程序运行的时候就会加载该类文件）</div><div class="line">+(void)load</div><div class="line">//在类被初始化之前会调用一次</div><div class="line">+(void)initialize</div></pre></td></tr></table></figure>
</li>
<li><p>iPad使用UIAlertController会crash<br><a href="http://stackoverflow.com/questions/31577140/uialertcontroller-is-crashed-ipad" target="_blank" rel="external">http://stackoverflow.com/questions/31577140/uialertcontroller-is-crashed-ipad</a></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac上 Hexo安装与配置]]></title>
      <url>https://slpowercoder.github.io/2016/09/02/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="1-安装node-js传送"><a href="#1-安装node-js传送" class="headerlink" title="1. 安装node.js传送"></a>1. 安装node.js<a href="https://nodejs.org/en/" target="_blank" rel="external">传送</a></h4><p>下载node的pkg包，点击直接安装，安装的过程下一步下一步就行了，新版的node.js包含有npm（npm用来安装hexo）</p>
<h4 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2. 安装hexo"></a>2. 安装hexo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm install -g hexo-cli</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>如果没有用sudo来执行命令可能会出现错误</p>
<h4 id="3-建立本地站点"><a href="#3-建立本地站点" class="headerlink" title="3. 建立本地站点"></a>3. 建立本地站点</h4><p>现在本地创建一个文件夹，作为本地站点的根目录，例如建立一个HexoBlog文件夹，<strong>cd到HexoBlog的上一级目录执行以下命令</strong></p>
<p><strong>1.初始化一个本地站点</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init HexoB<span class="built_in">log</span></div></pre></td></tr></table></figure>
<p><strong>2.进入站点根目录然后进行安装本地站点</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> HexoB<span class="built_in">log</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure>
<p><strong>3.生成静态页面</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g</div></pre></td></tr></table></figure>
<p><strong>4.启动本地站点服务器查看效果，执行本命令之后会提示出一个URL，将URL放入浏览器查看效果，按Ctrl+c关闭本地站点服务器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server</div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1. 基本配置"></a>1. 基本配置</h4><p><strong>1.在github上创建一个仓库，仓库的名字必须为”github用户名.github.io”</strong></p>
<p><strong>2.如果你使用过github，我猜你已经配置好了SSH key,这里我就不多说了，不过即使没有配置SSH key也没关系，只是以后每次提交的时候会提示要求输入密码</strong></p>
<p><strong>3.修改站点_config.xml文件，如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line"># Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type: git    #部署类型, 本文使用Git，发现使用github+SSH的方式会提示找不到github</div><div class="line">  repository: https://github.com/SLPowerCoder/SLPowerCoder.github.io  #部署的仓库url,发现使用github+SSH的方式会提示找不到github</div><div class="line">  branch: master   #部署分支,一般使用master主分支</div></pre></td></tr></table></figure>
<p><strong>4.这些基本的配置完成之后就可以执行命令部署到github上了</strong></p>
<p>执行下面的命令，安装git部署插件，不然执行了 hexo deploy之后会没有反应，也没有任何提示部署失败，其实是失败的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<p><strong>5.执行下面命令，用于生成静态文件并部署到远程站点，你也可以分两步写</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo g <span class="_">-d</span></div></pre></td></tr></table></figure>
<p>上述然后在浏览器中输入 github用户名.github.io就可浏览了</p>
<h4 id="2-博客主题配置"><a href="#2-博客主题配置" class="headerlink" title="2. 博客主题配置"></a>2. 博客主题配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"># Hexo Configuration</div><div class="line">## Docs: https://hexo.io/docs/configuration.html</div><div class="line">## Source: https://github.com/hexojs/hexo/</div><div class="line"></div><div class="line"># Site</div><div class="line">title: 枫叶</div><div class="line">subtitle: 枫叶</div><div class="line">description: 坐看云起时</div><div class="line">author: 枫叶</div><div class="line">language: zh-Hans </div><div class="line">timezone:</div><div class="line">email: sunlei_1030@126.com  # 邮箱</div><div class="line"></div><div class="line"></div><div class="line"># URL</div><div class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class="line">url: https://slpowercoder.github.io</div><div class="line">root: /</div><div class="line">permalink: :year/:month/:day/:title/</div><div class="line">permalink_defaults:</div><div class="line"></div><div class="line"># Directory</div><div class="line">source_dir: source</div><div class="line">public_dir: public</div><div class="line">tag_dir: tags</div><div class="line">archive_dir: archives</div><div class="line">category_dir: categories</div><div class="line">code_dir: downloads/code</div><div class="line">i18n_dir: :lang</div><div class="line">skip_render:</div><div class="line"></div><div class="line"># Writing</div><div class="line">new_post_name: :title.md # File name of new posts</div><div class="line">default_layout: post</div><div class="line">titlecase: false # Transform title into titlecase</div><div class="line">external_link: true # Open external links in new tab</div><div class="line">filename_case: 0</div><div class="line">render_drafts: false</div><div class="line">post_asset_folder: false</div><div class="line">relative_link: false</div><div class="line">future: true</div><div class="line">highlight:</div><div class="line">  enable: true</div><div class="line">  line_number: true</div><div class="line">  auto_detect: false</div><div class="line">  tab_replace:</div><div class="line"></div><div class="line"># Category &amp; Tag</div><div class="line">default_category: uncategorized</div><div class="line">category_map:</div><div class="line">tag_map:</div><div class="line"></div><div class="line"># Date / Time format</div><div class="line">## Hexo uses Moment.js to parse and display date</div><div class="line">## You can customize the date format as defined in</div><div class="line">## http://momentjs.com/docs/#/displaying/format/</div><div class="line">date_format: YYYY-MM-DD</div><div class="line">time_format: HH:mm:ss</div><div class="line"></div><div class="line"># Pagination</div><div class="line">## Set per_page to 0 to disable pagination</div><div class="line">per_page: 10</div><div class="line">pagination_dir: page</div><div class="line"></div><div class="line"># Disqus  disqus评论,  与多说类似, 国内一般使用多说</div><div class="line"># disqus_shortname: </div><div class="line">duoshuo_shortname: fengye1030   # 这里添加多说评论</div><div class="line"></div><div class="line"></div><div class="line"># Extensions</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: yelee  #默认是landscape 还有yelee,yilia等等</div><div class="line"></div><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type: git    #部署类型, 本文使用Git，发现使用github+SSH的方式会提示找不到github</div><div class="line">  repository: https://github.com/SLPowerCoder/SLPowerCoder.github.io  #部署的仓库url,采用https的,发现使用github+SSH的方式会提示找不到github</div><div class="line">  branch: master   #部署分支,一般使用master主分支</div></pre></td></tr></table></figure>
<h3 id="hexo的使用"><a href="#hexo的使用" class="headerlink" title="hexo的使用"></a>hexo的使用</h3><p><strong>1.创建文章（也可以把创建好的md文件直接放到根目录source/_posts目录中）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p><strong>2.清楚缓存的静态页面</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div></pre></td></tr></table></figure>
<p><strong>3.生成静态页面</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p><strong>4.运行本地服务器查看效果</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p><strong>5.部署到远程站点</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://hexo.io/" target="_blank" rel="external">hexo官网</a></p>
]]></content>
    </entry>
    
  
  
</search>
