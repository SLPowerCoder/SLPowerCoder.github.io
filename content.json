{"meta":{"title":"枫叶","subtitle":"枫叶","description":"坐看云起时","author":"枫叶","url":"https://slpowercoder.github.io"},"pages":[{"title":"categories","date":"2016-09-02T03:30:25.000Z","updated":"2017-02-26T14:48:48.000Z","comments":false,"path":"categories/index.html","permalink":"https://slpowercoder.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2016-09-02T03:53:42.000Z","updated":"2017-03-10T07:47:35.000Z","comments":false,"path":"about/index.html","permalink":"https://slpowercoder.github.io/about/index.html","excerpt":"","text":"枫叶 优秀的博客有很多，为什么还要创建这个博客呢？这个问题我也曾问过我自己，别人也问过我，思量良久只能说优秀的博客是别人的，不是你的，即使你天天逛别人家的博客也不如自己亲自写来的真实，没错就是这样。 喜欢捯饬捯饬博客，研究一些新的东西热衷于react native，cocos2d-x这些跨平台开发，梦想有一天能一统全栈 闲暇之余喜欢看看历史剧，如果你愿意和我聊历史，我就跟你聊到天荒地老 如果你要约我的话，👇下面有EMail github: “https://github.com/SLPowerCoder“CSDN: “http://blog.csdn.net/u014041012“简书: “http://www.jianshu.com/users/baaa48a4b911/latest_articles“Email: “sunlei_1030@126.com”"},{"title":"tags","date":"2016-09-02T03:50:27.000Z","updated":"2017-02-26T14:49:12.000Z","comments":false,"path":"tags/index.html","permalink":"https://slpowercoder.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"react-native组件间的通信","slug":"react-native组件间的通信","date":"2018-09-03T14:52:22.000Z","updated":"2018-09-03T14:54:18.372Z","comments":true,"path":"2018/09/03/react-native组件间的通信/","link":"","permalink":"https://slpowercoder.github.io/2018/09/03/react-native组件间的通信/","excerpt":"","text":"","categories":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/categories/react-native/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/tags/react-native/"},{"name":"通信","slug":"通信","permalink":"https://slpowercoder.github.io/tags/通信/"}],"keywords":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/categories/react-native/"}]},{"title":"RN与原生之间的通信方式","slug":"RN原生之间的通信方式","date":"2018-07-29T12:06:09.142Z","updated":"2018-07-29T12:12:46.058Z","comments":true,"path":"2018/07/29/RN原生之间的通信方式/","link":"","permalink":"https://slpowercoder.github.io/2018/07/29/RN原生之间的通信方式/","excerpt":"","text":"从原生到RN的通信可以通过bridge发送通知的方式来向RN通信 从RN到原生的通信通过实现RN的一些协议来用原生代码封装RN接口","categories":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/categories/react-native/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/tags/react-native/"}],"keywords":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/categories/react-native/"}]},{"title":"React Native的性能优化","slug":"React Native的性能优化","date":"2018-06-27T14:58:51.000Z","updated":"2018-07-15T03:58:12.950Z","comments":true,"path":"2018/06/27/React Native的性能优化/","link":"","permalink":"https://slpowercoder.github.io/2018/06/27/React Native的性能优化/","excerpt":"","text":"React Native的性能优化众所周知RN由于应用了virtual DOM 、diff算法等一些列调优机制，使RN应用几乎达到了与原生一样的体验，但是毕竟RN只是原生APP的一个线程而已，RN和原生还隔着一道桥梁batch bridge，最终RN的代码还是要通过jscore引擎转换成原生代码来执行，这就决定了RN不可能超越原生，除非RN能越过这道坎，尽管官方替我们做了一些优化，但是有些优化只能交给了用户来决定，比如sholdComponentUpdate是返回true还是false，这是需要我们来决定的，再比如APP的页面如果非常多的话，打包之后bundle非常大，而加载和初始化bundle又很耗时间，这又需要拆分bundle，所以还是有许多需要人工来优化。 既然是性能优化那就肯定得找出RN的性能瓶颈在哪 一、基础优化（目的是尽量减少页面的渲染） 比较吃性能的、耗时的操作可以放到componentDidMount中，然后再用Interaction manager在包裹一下，比如网络请求。 尽量少用状态组件，尽可能用无状态组件，无状态组件不会被实例化，可以提升性能 自定义的有状态组件尽量继承自pure component，这样系统会自动在shouldComponentUpdate中默认做一层浅比较（直接拿两个对象做比较，对象中的子元素不做比较），可以减少一些不必要的渲染，当然你也也可以在该方法中做深层次的比较，如果组件不是继承自PureComponent则该方法默认返回true，这样会导致很多无用的渲染，比如父组件的改变会导致子组件的重新render。 利用immutable不可变数据，提升性能，它可以避免本来应该渲染而实际却没有发生渲染的问题，因为框架默认在shouldComponentUpdate做的是一层浅比较，如果在state改变的过程中做的是浅拷贝，则state改变之前和改变之后是相等的，指向的是同一个对象，这样浅比较会认为state没有改变而不做渲染。 对于同层级的相同类型的组件，要给每个组件指定唯一的key值。例如通常我们在一个容器组件中创建多个子组件的时候，我们会把这些子组件放在一个数组里，然后把数组直接放到容器页面中，形如下面的伪代码： 1234567banner = ()=&gt;&#123; let childArr = []; while(let i &lt; 10) &#123; childArr.push(&lt;Child key=&#123;XXXXXX&#125;&gt;&lt;/Child&gt;) &#125; return &lt;View&gt; &#123;childArr&#125; &lt;/View&gt;&#125; Child组件的key一定要有，这涉及到diff算法的原理，diff算法是按层级进行比较的，当前的virtual DOM 和之前的virtual DOM进行同层级比较的时候，对于属于同一个父组件的同一层级的子组件，如果没有key值的话，RN需要遍历该父组件的所有子组件来行进对比，才能知道哪一个子组件发生了改变，这样如果子组件的数量很大的时候会很耗性能，RN有可能会因为遍历的耗时而选择放弃对比来重新渲染所有的子组件，但是如果有key值的话可以利用key直接进行两两比较，效率就高出很多。 列表优化，几乎所有的APP都有列表，所以列表的优化尤为重要，之前RN采用的是listView，数据稍微大的时候会出现明显卡顿，有性能瓶颈，最后RN在xxx版推出了新的列表神器FlatList和SectionList，他俩都是继承自VirtualizedList，比listView的性能更高，并且使用起来也更简单了，无需再想listView一样要先创建一个DataSource对象了。具体优化可以参考官网。。。 用FlatList替换scrollView，因为在用scrollView的时候它会一下子把他上面的所有子组件都渲染出来，而FlatList可以设置首屏渲染的行数，这样就不会导致在刚进入这一页的时候出现卡顿现象。 二、本地分包优化从官方给出的RN耗时图可以看出，最耗性能的地方是bundle包的JS环境的初始化和加载，所以这一块的优化也至关重要，bundle体积过大会导致加载慢，其中bundle包括react等基础库以及引入的三方库 和 你自己的业务代码，可以先从两方面着手。第一：需要尽可能的优化bundle的体积，去掉一些不必要的资源。第二：做拆分处理，把bundle拆分成基础bundle和业务bundle。 基础bundle是APP必须依赖的公共基础部分。其实拆分之后还是很耗时间，所以我们又做了另一种处理，那就是预加载，对基础bundle进行预加载，这样可以减少一些加载以及初始化的耗时。 总结如下： 本地分包： 把bundle拆分成公共基础bundle和业务bundle 预加载： 预加载公共基础bundle 三、按需延迟加载可以通过require来实现动态延迟加载,伪代码如下： 12345678910111213import xxx from &apos;./xxxx&apos;let test2;export default class Test extent Componnet &#123; getTest2 = ()=&gt;&#123; // 对test2模块进行懒加载（延迟加载），以提高性能 if(test2 === undefined) &#123; test2 = require(&apos;./xxxx/test2&apos;); &#125; &#125;&#125; 我们不需要再这个test模块一开始就加载test2模块，这样可以延迟加载一些不是立马需要的其他模块，提升整体加载速度，降低内存。","categories":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/categories/react-native/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/tags/react-native/"}],"keywords":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/categories/react-native/"}]},{"title":"滴滴面试总结","slug":"滴滴面试总结","date":"2018-06-15T14:32:51.000Z","updated":"2018-06-26T14:40:06.823Z","comments":true,"path":"2018/06/15/滴滴面试总结/","link":"","permalink":"https://slpowercoder.github.io/2018/06/15/滴滴面试总结/","excerpt":"","text":"下面是面试滴滴的经历，总共出了四道技术面试题，说不出的辛酸。。。日后有时间在总结答案，先记录下来 1、实现一个游戏人物GameRole，包含年龄、性别、装备（可以动态增减），不是Xcode，是一个没有提示的编辑器，徒手写，类名忘写了。。。 2、GameRole *role = [GameRole alloc] init…]; &nbsp;&nbsp;&nbsp; 问：role的内存大小？ 3、伪代码如下，这三行代码编译、运行的时候有什么问题，是会出现crash、警告或者出现其他情况，请说明原因 123NSString *obj = [[NSData alloc] init];NSInteger length = obj. length;NSString *testStr = [obj stringApendString....]; 4、appdelegate中的didfinishedLanch方法中，伪代码如下: 12345678910111213-appdelegate：didfinishedLanch ｛ dispatch_async(globalqueue,^&#123; [self testTimer]; &#125;)｝-testTimer &#123; NSTimer *timer = [NSTimer scheduleTimerWith:timerActiom];&#125;-timerActiom &#123; NSLog(@“timer action”);&#125; 上述代码问题吗？有什么问题？怎么解决？ 4、函数指针和block的区别？ 答：block的本质是结构体，使用比函数指针方便，函数指针可以作为方法参数实现回调追问：block为什么设计成结构体的方式？答：。。。。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/tags/iOS/"},{"name":"面试","slug":"面试","permalink":"https://slpowercoder.github.io/tags/面试/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}]},{"title":"写这篇blog内心是崩溃的","slug":"一次masonry布局错误后的自检","date":"2017-05-13T13:09:34.000Z","updated":"2017-05-13T17:00:51.000Z","comments":true,"path":"2017/05/13/一次masonry布局错误后的自检/","link":"","permalink":"https://slpowercoder.github.io/2017/05/13/一次masonry布局错误后的自检/","excerpt":"","text":"在某一个月黑风高的夜里，他正在伏案敲代码，敲完之后一脸自信的cmd + run，结果不愉快的事情就此发生了，心塞。。😂事情是这样的，我们美丽的UI设计了一套图，本来想自定义个flowLayout走个捷径的，事实却发现走了个大弯路，图是下面这样子的👇 约束报错，很是无奈，于是我又到GitHub上查看了一遍masonry的使用方式，现总一下。 iOS布局有这么几种方式：frame：你要看吗？我并不打算写autoResize：autoresizingMask是view的一个布局属性，默认值是UIViewAutoresizingNone，这个枚举值有很多值，具体自己查看autoLayout：自动布局出来以后，很受欢迎，为此苹果还设计了VFL可视化语言，但是程序员是很懒的（不是说不会偷懒的程序员不是好程序员吗，所以我说程序员懒并不是贬义词），然后masonry就诞生了，masonry是一个对NSLayoutConstraint的封装具备链式语法的三方布局库，很受大家欢迎，我不敢说没人用frame布局，但是我敢说没几个人还在用NSLayoutConstraint来布局了吧 masonry的具体用法就不说了，GitHub上有详细的用法，下面就提一下masonry一些你值得注意的地方。 masrony 提供的一个利于debug约束问题的方法，代码摘自masonry的demo上的，我加了注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344 UIView *greenView = UIView.new; greenView.backgroundColor = UIColor.greenColor; [self addSubview:greenView]; UIView *redView = UIView.new; redView.backgroundColor = UIColor.redColor; [self addSubview:redView]; UILabel *blueView = UILabel.new; blueView.backgroundColor = UIColor.blueColor; [self addSubview:blueView]; UIView *superview = self; int padding = 10; // 给视图添加key的方式有两种，如下所示 // 法一： //you can attach debug keys to views like so: // greenView.mas_key = @&quot;greenView&quot;; // redView.mas_key = @&quot;redView&quot;; // blueView.mas_key = @&quot;blueView&quot;; // superview.mas_key = @&quot;superview&quot;; // 法二： //OR you can attach keys automagically like so: MASAttachKeys(greenView, redView, blueView, superview); // 给约束添加key [blueView mas_makeConstraints:^(MASConstraintMaker *make) &#123; //you can also attach debug keys to constaints make.edges.equalTo(@1).key(@&quot;ConflictingConstraint&quot;); //composite constraint keys will be indexed make.height.greaterThanOrEqualTo(@5000).key(@&quot;ConstantConstraint&quot;); make.top.equalTo(greenView.mas_bottom).offset(padding); make.left.equalTo(superview.mas_left).offset(padding); make.bottom.equalTo(superview.mas_bottom).offset(-padding).key(@&quot;BottomConstraint&quot;); make.right.equalTo(superview.mas_right).offset(-padding); make.height.equalTo(greenView.mas_height); make.height.equalTo(redView.mas_height).key(@340954); //anything can be a key &#125;]; return self;&#125; 上面的约束有问题，会抛出问题，如果不给视图和约束设置key的话，xcode提示错误如下：12345678Probably at least one of the constraints in the following list is one you don&apos;t want. Try this: (1) look at each constraint and try to figure out which you don&apos;t expect; (2) find the code that added the unwanted constraint or constraints and fix it. ( &quot;&lt;MASLayoutConstraint:0x6000000a5e20 UILabel:0x7fb318c2c990.left == MASExampleDebuggingView:0x7fb318c15c00.left + 1&gt;&quot;, &quot;&lt;MASLayoutConstraint:0x6080000a40e0 UILabel:0x7fb318c2c990.left == MASExampleDebuggingView:0x7fb318c15c00.left + 10&gt;&quot;) 给视图和约束添加了key之后的提示如下：12345678Probably at least one of the constraints in the following list is one you don&apos;t want. Try this: (1) look at each constraint and try to figure out which you don&apos;t expect; (2) find the code that added the unwanted constraint or constraints and fix it. ( &quot;&lt;MASLayoutConstraint:ConflictingConstraint[0] UILabel:blueView.left == MASExampleDebuggingView:superview.left + 1&gt;&quot;, &quot;&lt;MASLayoutConstraint:0x6000000b7ac0 UILabel:blueView.left == MASExampleDebuggingView:superview.left + 10&gt;&quot;) 是不是看着爽多了。。这样你就能看到具体是哪个view的哪个约束可能出现问题了，而不是出现一堆的十六进制地址 2.添加或者更新(update、remake)约束的代码应该放在哪，代码如下一看便知 1234567891011121314151617181920// 当你使用autoLayout布局的时候建议写此方法，防止autoresize布局造成的错误+ (BOOL)requiresConstraintBasedLayout&#123; return YES;&#125;// this is Apple&apos;s recommended place for adding/updating constraints// 苹果推荐添加或者更新（update、remake）约束的地方- (void)updateConstraints &#123; [self.growingButton updateConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(self); make.width.equalTo(@(self.buttonSize.width)).priorityLow(); make.height.equalTo(@(self.buttonSize.height)).priorityLow(); make.width.lessThanOrEqualTo(self); make.height.lessThanOrEqualTo(self); &#125;]; // according to apple super should be called at end of method [super updateConstraints];&#125; 3.autoLayout不允许对其属性例如左、右、centerY等被设置为常量，因此如果你要给这些属性传递一个NSNumber类型的值得时候masonry会将他们转换成与父视图相关的约束。 1234567However Auto Layout does not allow alignment attributes such as left, right, centerY etc to be set to constant values. So if you pass a NSNumber for these attributes Masonry will turn these into constraints relative to the view’s superview ie: [view makeConstraints:^(MASConstraintMaker *make) &#123; make.left.lessThanOrEqualTo(@10) &#125;]; view的左边距等价于 view.left = view.superview.left + 10 4.按比例布局，如果各占一半的话，也可以不用multipliedBy，直接约束两个视图的width isEqual就行了 1234// topInnerView的宽度是高度的1/3[self.topInnerView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.equalTo(self.topInnerView.mas_height).multipliedBy(3);] 5.你用NSAutoLyoutConstraints布局的时候需要设置视图的view1.translatesAutoresizingMaskIntoConstraints = NO，默认值是YES，等于YES的时候autoresize会影响autolayout布局，有时会发现效果不是自己想要的，不过如果你用masonry设置约束的时候，masonry会帮你把这个属性值设置为NO，你不用管它，写出来就是想提醒你。 6.看完官方的demo，发现他们会把需要的每个约束都写上，但是有时候不需要全写上，如下面被我注释的代码，但是官方是没有注释的，既然人家官方都这样写，你是不是也应该这样写啊，别注释了，这样不容易出错，如下： 12345678910111213141516171819202122232425262728293031323334353637 UIView *superview = self; int padding = 10; //if you want to use Masonry without the mas_ prefix //define MAS_SHORTHAND before importing Masonry.h see Masonry iOS Examples-Prefix.pch [greenView makeConstraints:^(MASConstraintMaker *make) &#123; make.top.greaterThanOrEqualTo(superview.top).offset(padding); make.left.equalTo(superview.left).offset(padding); make.bottom.equalTo(blueView.top).offset(-padding); make.right.equalTo(redView.left).offset(-padding); make.width.equalTo(redView).multipliedBy(1); make.height.equalTo(redView.height); make.height.equalTo(blueView.height); &#125;]; //with is semantic and option [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(superview.mas_top).with.offset(padding); //with with //make.left.equalTo(greenView.mas_right).offset(padding); //without with make.bottom.equalTo(blueView.mas_top).offset(-padding); make.right.equalTo(superview.mas_right).offset(-padding); // make.width.equalTo(greenView).multipliedBy(1); make.height.equalTo(@[greenView, blueView]); //can pass array of views &#125;]; [blueView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(greenView.mas_bottom).offset(padding); make.left.equalTo(superview.mas_left).offset(padding); make.bottom.equalTo(superview.mas_bottom).offset(-padding); make.right.equalTo(superview.mas_right).offset(-padding); make.height.equalTo(@[greenView.mas_height, redView.mas_height]); //can pass array of attributes &#125;]; return self;&#125; 要注意blueView设置高度依赖的时候设置的是一个数组这样的用法 7.masonry动画 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@implementation MASExampleUpdateView- (id)init &#123; self = [super init]; if (!self) return nil; self.growingButton = [UIButton buttonWithType:UIButtonTypeSystem]; [self.growingButton setTitle:@&quot;Grow Me!&quot; forState:UIControlStateNormal]; self.growingButton.layer.borderColor = UIColor.greenColor.CGColor; self.growingButton.layer.borderWidth = 3; [self.growingButton addTarget:self action:@selector(didTapGrowButton:) forControlEvents:UIControlEventTouchUpInside]; [self addSubview:self.growingButton]; self.buttonSize = CGSizeMake(100, 100); return self;&#125;+ (BOOL)requiresConstraintBasedLayout&#123; return YES;&#125;// this is Apple&apos;s recommended place for adding/updating constraints// 苹果推荐添加或或者更新约束的地方- (void)updateConstraints &#123; [self.growingButton updateConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(self); make.width.equalTo(@(self.buttonSize.width)).priorityLow(); make.height.equalTo(@(self.buttonSize.height)).priorityLow(); make.width.lessThanOrEqualTo(self); make.height.lessThanOrEqualTo(self); &#125;]; // according to apple super should be called at end of method [super updateConstraints];&#125;- (void)didTapGrowButton:(UIButton *)button &#123; self.buttonSize = CGSizeMake(self.buttonSize.width * 1.3, self.buttonSize.height * 1.3); // tell constraints they need updating // 告诉约束系统要更新，系统会调用上面重写的updateConstraints方法 [self setNeedsUpdateConstraints]; // update constraints now so we can animate the change, // it will be call by system automatically // 该方法不必手动调用 // [self updateConstraintsIfNeeded]; // 可以用layoutIfNeeded来实现即时更新，还可以添加动画 [UIView animateWithDuration:0.4 animations:^&#123; [self layoutIfNeeded]; // 需要在此处调用layoutIfNeeded方法才能产生动画 &#125;];&#125;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}],"tags":[{"name":"masonry","slug":"masonry","permalink":"https://slpowercoder.github.io/tags/masonry/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}]},{"title":"react native集成到原有的项目中(iOS)","slug":"react native集成到原有的项目中(iOS)","date":"2017-05-01T16:44:35.000Z","updated":"2017-05-01T17:19:09.000Z","comments":true,"path":"2017/05/02/react native集成到原有的项目中(iOS)/","link":"","permalink":"https://slpowercoder.github.io/2017/05/02/react native集成到原有的项目中(iOS)/","excerpt":"","text":"接触RN也有一段时间了，基本上来说算是入门了，到目前RN的应用还没有达到期望的广泛度，大部分还是以原生+RN的方式进行混合开发，今天抽空写一下关于RN嵌入到iOS原生项目中的知识点。 前期准备现在大部分嵌入方式都是采用cocoapods的方式引入RN依赖库到原生项目中，当然你也可以选择手动方式，不过很麻烦，本文采用的cocoapods来管理依赖。RN所需要的环境也要装好，中文网有，具体我就不说了 集成用Xcode创建一个项目，然后在项目中创建一个目录，把RN相关的都放在里面，如下图，我创建了一个js目录（这个目录你也可以放到iOS项目的根目录，任意）。然后cd到刚刚创建的js目录中，执行npm init，这时js目录中会多出一个package.json文件，这个文件和iOS中的Podfile类似，是用来记录着RN工程中要安装的依赖，目前你只需要关注dependencies这一项(把下面的内容覆盖到你生成的package.json文件中)，该项中记录着RN项目要安装的依赖库。 1234567891011121314151617181920212223&#123; \"name\": \"MixRNAndIOS\", \"version\": \"0.0.1\", \"private\": true, \"scripts\": &#123; \"start\": \"node node_modules/react-native/local-cli/cli.js start\", \"test\": \"jest\" &#125;, \"dependencies\": &#123; \"react\": \"15.3.2\", \"react-native\": \"^0.36.1\" &#125;, \"jest\": &#123; \"preset\": \"jest-react-native\" &#125;, \"devDependencies\": &#123; \"babel-jest\": \"16.0.0\", \"babel-preset-react-native\": \"1.9.0\", \"jest\": \"16.0.2\", \"jest-react-native\": \"16.0.0\", \"react-test-renderer\": \"15.3.2\" &#125;&#125; 紧接着我们用npm包管理器来安装RN的依赖库，还是在js目录执行npm install,安装完毕之后，js目录会多出一个名为node_modules文件夹，RN所必须依赖的库都在这里面，然后我们创建一个index.ios.js作为RN项目的入口文件（名字可以任意起），然后我们就可以在入口文件中愉快的写RN代码了。 上面的步骤顺利执行完之后，RN项目已经完成了，现在我们要把RN集成到iOS原生项目中。 在项目根目录创建一个Podfile文件，如下所示，在项目的根目录执行pod install 来安装Podfile中指定的依赖库。 123456789101112131415# The target name is most likely the name of your project.target &apos;MixRNAndIOS&apos; do # Your &apos;node_modules&apos; directory is probably in the root of your project, # but if not, adjust the `:path` accordingly pod &apos;React&apos;, :path =&gt; ‘./MixRNAndIOS/js/node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTNetwork&apos;, &apos;RCTWebSocket&apos;, # needed for debugging # Add any other subspecs you want to use in your project &apos;RCTImage&apos;, ]end 注意：Podfile文件中的path路径用pod安装完iOS所依赖的RN库之后我们就可以着手集成RN了。 RN为我们在iOS平台上提供了一个RCTRootView，RCTRootView是继承自iOS中UIView类，所以你可以像使用UIView一样使用RCTRootView，RN与iOS的交互都要在RCTRootView中进行，本篇文章先不讲交互的事，只讲集成，先把代码贴上，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import &quot;ViewController.h&quot;import &quot;RCTRootView.h&quot;@interface ViewController ()@property (nonatomic, strong) NSDictionary *props;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.props = @&#123; @&quot;param&quot; : @[ @&#123; @&quot;name&quot; : @&quot;Alex&quot;, @&quot;des&quot;: @&quot;hello，我是从原生传递给RN界面的参数&quot; &#125; ] &#125;; UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake((self.view.bounds.size.width - 300)/2, 200, 300, 40)]; [btn setTitle:@&quot;点我进入react native界面&quot; forState:UIControlStateNormal]; [btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [btn addTarget:self action:@selector(highScoreButtonPressed) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn];&#125;- (void)highScoreButtonPressed&#123; NSURL *jsCodeLocation; #ifdef DEBUG //开发的时候用，需要打开本地服务器 jsCodeLocation = [NSURL URLWithString:@&quot;http://localhost:8081/index.ios.bundle?platform=ios&quot;];#else //发布APP的时候用 jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;index.ios&quot; withExtension:@&quot;jsbundle&quot;];#endif RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL : jsCodeLocation moduleName : @&quot;RNHighScores&quot; initialProperties : self.props //将native数据传送到RN中 launchOptions : nil]; rootView.frame = [UIScreen mainScreen].bounds; UIViewController *vc = [[UIViewController alloc] init]; vc.view.backgroundColor = [UIColor redColor]; [vc.view addSubview:rootView]; [self presentViewController:vc animated:YES completion:nil];&#125; 创建RCTRootView，将RCTRootView添加到VC中的view上就OK了jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;index.ios&quot; withExtension:@&quot;jsbundle&quot;];这一行你先忽略，后面会说。然后cd到js目录，执行react-native start或者执行npm start，来启动本地node服务器，如果没有错误的话我们就只需最后一步了，用Xcode打开项目，运行项目，大功告成。 打RN离线包此时我们的项目是依赖于刚刚启动的本地服务器的，要是上线怎么办，所以我们需要打个RN离线包，这样就可以摆脱本地服务器了。进入js目录，创建一个bundle目录，这里面存放打包后的RN资源，包括RN代码和图片等静态资源，在js目录里执行下面的打包命令，1react-native bundle --entry-file ./index.ios.js --bundle-output ./bundle/index.ios.jsbundle --platform ios --assets-dest ./bundle --dev false 如果成功的话，在bundle目录下会生成存放RN静态资源的assert目录和RN的index.ios.jsbundle代码文件，将这俩家伙拖进Xcode中 注意：要以引用的方式拖进Xcode中。 在文章的集成部分我粘贴了一大段代码，源代码中有两句代码用来生成RN资源的URL，第一句是依赖本地服务器的，一般调试RN代码时用，第二句是引入打包后的RN资源的URL，发布APP的时候用的，我用宏来进行控制。1jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;index.ios&quot; withExtension:@&quot;jsbundle&quot;]; 注意：假如我们把第一种获取URL的方式注释掉，宏也注释掉，如果iOS项目是DEBUG模式，而我们加载的明明是RN的离线包，你会发现从原生页面跳转到RN页面的时候，顶部的statusBar会有加载资源的进度显示，不要纠结，运行项目的时候改成release模式就好了，来张效果图。 友情提示，在RN中想引入iOS中Assets.xcassets里面的图片的话可以直接写图片的文件名，如下面这样。1&lt;Image source=&#123;&#123;uri:&apos;happiness.jpg&apos;&#125;&#125; style=&#123;styles.happy&#125;/&gt;","categories":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/categories/react-native/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/tags/react-native/"}],"keywords":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/categories/react-native/"}]},{"title":"Block深入理解","slug":"block","date":"2017-03-14T08:36:04.000Z","updated":"2017-03-25T05:11:24.000Z","comments":true,"path":"2017/03/14/block/","link":"","permalink":"https://slpowercoder.github.io/2017/03/14/block/","excerpt":"","text":"block 你应该了解的知识为什么不把本部分放到本质部分的下面呢，我以为实用为大，还是先把block的使用及其注意点写在前面吧。 1、为了方便声明block类型的变量，我们一般用typedef typedef void (^Block)(void)给block类型起个别名，这样我们就可以直接按如下方式声明block变量了。 123456789typedef void (^Block)(void);int main(int argc, const char * argv[]) &#123;//这样声明Block block = ^&#123;&#125;;//而不是这样//void(^block)(void)=^&#123;&#125;;return 0;&#125; 2、在非ARC情况下，定义块的时候（无论是全局块还是局部块），其所占的内存区域是分配在栈中的。如下声明了一个block，如下面的代码就有危险，在条件语句实现的两个block都分配在栈内存中，于是这两个块只在对应的条件语句范围内有效，这样写的代码可以编译，但是运行起来却是时而对时儿错，若编译器未复写待执行的块，则程序正常运行，若复写则程序奔溃。 1234567891011void (^block)();if(/*some condition*/)&#123;block = ^&#123;NSLog(@&quot;Block A&quot;);&#125;;&#125;else&#123;block = ^&#123;NSLog(@&quot;Block B&quot;);&#125;;&#125;block(); 应该按这样的姿势写 1234567891011void (^block)();if(/*some condition*/)&#123;block = [^&#123;NSLog(@&quot;Block A&quot;);&#125; copy];&#125;else&#123;block = [^&#123;NSLog(@&quot;Block B&quot;);&#125; copy];&#125;block(); 3、同理2，将block声明为属性的时候，要用copy，还要注意如果你不确定你生命的这个block属性会不会被其他线程修改，你就用atomic加个原子锁，这样就线程安全了 1@property (copy) Block block; //属性默认就是atomic 4、调用block的时候，有些童鞋的姿势不太对，假如我声明了一个block属性，正确调用姿势如下 1234Block block = self.block;if(block)&#123;block();&#125; 大部分童鞋会按下面这样写，那些连判断都不做的童鞋我就不批评你了，回去面壁去 123456if(self.block)&#123;//我是其他线程，我要这里要捣乱block();&#125; 上面的写法为什么不妥呢，因为即使self.block当时存在，如果另一个线程在该线程执行到我注释的那一行的时候把block置空了咋办，你再调用是不是就得到了一个完美的闪退，但是我如果把self.block 赋值给了一个局部变量的话，其他线程修改的是self.block而修改不了这个零时变量，所以上面的那种姿势不太稳妥。如果你看过AF的源码你就会发现，歪果仁就是按着我说的上面的正确姿势写的。 5、为什么用了__block就可以修改所截获的变量了？ 因为block的特性，编译器不允许在block内直接修改所捕获的变量，但是我们可以修改__block修饰的自动变量，因为用__block修饰过之后，原先存储在栈中的变量就变成了存在堆中了，查看用clang过后的cpp文件你会发现在block中多了一个与该变量同名的__Block_byref_i_0结构体的指针变量，其中包含了存储在堆中的那个变量，可以通过结构体指针变量来直接更改变量的值，而没有用__block修饰的变量，block会把截获的变量copy为自己的一个变量。 6、避免循环引用，如果你把一个block声明成了对象的一个属性，那么该对象就会持有这个block，如果在该对象中要实现block属性的话，用到self的时候要用__weak修饰过的，不然会循环引用。 7、block的存储位置，栈、堆、全局数据区（强调一下如非特殊说明，block都是函数中实现）block是否截获外围变量会影响他的存储区域的。 7.1 下图是ARC模式下执行的代码7.2 下图是非ARC模式下执行的代码 解释一下上面的结果，学过C的都知道，malloc是分配到堆中了，global是分配到全局数据区了。 7.3.1 MRC下此种写法Xcode会报错，但是如果不引用外围变量的话就没事，如果你仔细看7.1与7.2的介绍，你就知道原因了，不过我还是想说一下。因为在MRC情况下引入外围变量时，此种写法的block存在栈里面，而该函数的却返回了block，return标志着一个函数的结束，所以在return的时候block会被释放而报错，在MRC情况下不引入外围变量的话，此种写法的block存在全局数据区里，所以没问题。 7.3.2 ARC下，无论引不引入外围变量，都没事，不引入返回的block存在全局数据区，引入的话存在堆中。就不截图了。 7.4 下面这种情况，ARC与MRC下block都存储在全局数据区，这种情况不常出现，一般我们都是在函数中来是实现block的。 7.5 总结（强调一下如非特殊说明，block都是函数中实现）： ARC模式下：不论你声明的是局部block还是全局block，它们只要不截获外围变量，它们都会存储在全局数据区的，如果截获外围变量，block就会存储在堆（heap）中。 非ARC模式下：不论你声明的是局部block还是全局block，它们只要不截获外围变量，它们都会存储在全局数据区的，如果截获外围变量，block就会存储在栈(stack)中。 两种模式下的差别：只要不截获外围变量block一律都存在全局数据区，只有截获了外围变量ARC和MRC才有所区别，而开发中往往我们的block都是后面这么一个情况，现在很少有人使用非ARC了吧，所以还是关注ARC的情况吧，即你只需要记住结论的第一条就好了。 block 的本质block其本质是一个struct，也可以说是一个含有自动变量的匿名函数，通过clang编译器转换成C++代码可以看出，执行clang -rewrite-objc 要转换的OC文件命令，可以在同级目录下获得一个.cpp文件，里面就是转换后的OC代码，下面我会分三种情况给出OC代码及其对应的cpp代码。 1、只是纯粹的在入口函数中定义了一个block，block中也没有引入外围变量 1234567891011#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123;void(^block)(void)=^&#123;NSLog(@&quot;Block!!&quot;);&#125;;block();return 0;&#125; 下面是转换后的C++代码，为了方便观察，我把文件最下方的有关block的代码摘录如下 12345678910111213141516171819202122232425262728293031323334//block的结构体struct __main_block_impl_0 &#123;//block的实现struct __block_impl impl;//block的描述（包含block的大小以及copy，dispose等）struct __main_block_desc_0* Desc;//block的构造函数，对block结构体成员变量的初始化__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;;//block内的代码实现部分static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1q_hr0kg_v15rj7ry_618ljfldr0000gn_T_hellow_a5b27a_mi_0);&#125;//block的描述，包含block的大小以及copy，disposestatic struct __main_block_desc_0 &#123;size_t reserved;size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;//OC中的main函数int main(int argc, char * argv[]) &#123;void(*block)(void)=((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);return 0;&#125; 2、在入口函数中定义了一个block，并在block中引入外围整型变量i 1234567891011121314#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123;//自动变量iint i = 10;void(^block)(void)=^&#123;NSLog(@&quot;Block!!---%d&quot;,i);&#125;;block();return 0;&#125; 转换后的cpp代码 12345678910111213141516171819202122232425262728293031struct __main_block_impl_0 &#123;struct __block_impl impl;struct __main_block_desc_0* Desc;//这是block捕获的变量int i; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) &#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;int i = __cself-&gt;i; // bound by copyNSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1q_hr0kg_v15rj7ry_618ljfldr0000gn_T_main_1b12e5_mi_0,i);&#125;static struct __main_block_desc_0 &#123;size_t reserved;size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main(int argc, const char * argv[]) &#123;int i = 10;void(*block)(void)=((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i));((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);return 0;&#125; 3、在入口函数中定义了一个block，并在block中引入外围整型变量i，并且i用__block修饰 1234567891011121314#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123;__block int i = 10;void(^block)(void)=^&#123;i += 1;NSLog(@&quot;Block!!---%d&quot;,i);&#125;;block();return 0;&#125; 转换后的cpp代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//存储block截获的外围变量的一个结构体struct __Block_byref_i_0 &#123;void *__isa;__Block_byref_i_0 *__forwarding;int __flags;int __size;int i;&#125;;struct __main_block_impl_0 &#123;struct __block_impl impl;struct __main_block_desc_0* Desc;//这是block捕获的变量__Block_byref_i_0 *i; // by ref__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) &#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;__Block_byref_i_0 *i = __cself-&gt;i; // bound by ref(i-&gt;__forwarding-&gt;i) += 1;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1q_hr0kg_v15rj7ry_618ljfldr0000gn_T_main_10e8d1_mi_0,(i-&gt;__forwarding-&gt;i));&#125;//下面两个指针函数是__main_block_desc_0结构体中的函数指针的实现，前者是要保留block截获的对象，后者则将之释放static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;//block的描述static struct __main_block_desc_0 &#123;size_t reserved;size_t Block_size;void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;//主函数int main(int argc, const char * argv[]) &#123;__attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 10&#125;;void(*block)(void)=((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344));((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);return 0;&#125; 第一种和第二种比较可知，当block截获外围变量时，block会把截获的变量注册成为自己的成员变量，这也是为什么block不能直接修改截获的变量的原因，因为在block内操作的外围变量其实是block的同名的成员变量。 第一种和第三种比较可知，当block截获外围变量时，block会把截获的变量封装成__Block_byref_i_0结构体，并把结构体指针变量注册为自己的成员变量。 被__block修饰的外围变量会变成堆变量，这样这个外围变量就不会随函数的结束而被释放了，__Block_byref_i_0结构体i指针变量中有一个指向自己的__forwarding指针，通过i-&gt;__forwarding-&gt;i来修改存在堆中的外围变量。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}],"tags":[{"name":"block","slug":"block","permalink":"https://slpowercoder.github.io/tags/block/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}]},{"title":"iOS音频的播放以及录制","slug":"iOS音频的播放以及录制","date":"2017-03-10T09:39:03.000Z","updated":"2017-03-10T09:46:12.000Z","comments":true,"path":"2017/03/10/iOS音频的播放以及录制/","link":"","permalink":"https://slpowercoder.github.io/2017/03/10/iOS音频的播放以及录制/","excerpt":"","text":"iOS中的音频包括两种类型，一种是时间比较短无需监听播放时间等属性的音效，一种是时间比较长的音乐","categories":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}],"tags":[{"name":"audio","slug":"audio","permalink":"https://slpowercoder.github.io/tags/audio/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}]},{"title":"iOS 深拷贝和浅拷贝","slug":"iOS 深拷贝和浅拷贝","date":"2017-02-11T15:44:10.000Z","updated":"2017-02-28T09:56:45.000Z","comments":true,"path":"2017/02/11/iOS 深拷贝和浅拷贝/","link":"","permalink":"https://slpowercoder.github.io/2017/02/11/iOS 深拷贝和浅拷贝/","excerpt":"","text":"浅拷贝只是增加了一个对被引用对象的一个指向，拷贝出的对象与原对象共用一块内存区域。retain：只是retainCount加一，实际上还是共用一块内存copy：不论拷贝的是不是集合对象，只要被拷贝的对象是不可变的，那就是浅拷贝，仅仅retainCount加一 深拷贝会分配出一块内存，然后将引用的内容拷贝进去，也就是说拷贝出来的对象与原对象是独立的。copy：拷贝可变对象则是深拷贝mutableCopy：不论被拷贝的是不是集合对象，是可变的还是不可变的，都是深拷贝 注意：如果mutableCopy的是集合对象，深拷贝的是该集合对象，不是指该集合对象里面的元素，称之为单层深拷贝，对于集合对象内的元素依然是指针拷贝 总结copy：只要copy的是不可变对象，都是浅拷贝，copy可变集合象则是单层深拷贝，拷贝可变非集合对象则是深拷贝mutableCopy：拷贝集合象则是单层深拷贝，拷贝非集合对象则是深拷贝","categories":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}],"tags":[{"name":"深拷贝","slug":"深拷贝","permalink":"https://slpowercoder.github.io/tags/深拷贝/"},{"name":"浅拷贝","slug":"浅拷贝","permalink":"https://slpowercoder.github.io/tags/浅拷贝/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}]},{"title":"Objective-C 消息转发机制","slug":"Objective-C 消息转发机制","date":"2017-02-11T15:41:29.000Z","updated":"2017-03-01T07:06:47.000Z","comments":true,"path":"2017/02/11/Objective-C 消息转发机制/","link":"","permalink":"https://slpowercoder.github.io/2017/02/11/Objective-C 消息转发机制/","excerpt":"","text":"一图胜千言，习惯性的先来一张图以便对消息转发有个整体的把握 运行时系统库方法查询流程图 对于对象无法处理的消息，如果不做转发处理的话，程序最终会调用NSObjective的doesNotRecognizeSelector:消息将程序crash掉。 Objective-C提供了两种消息转发选项 快速转发：NSObject类的子类A可以通过重写NSObject类的forwardingTargetForSelector:方法，将A的实例无法识别的消息转发给目标对象B，从而实现快速转发。该技巧就像是将对象的实现代码与转发对象合并到一起。这类似于实现的多继承行为。如果你有一个定了对象 能够消化哪些消息的目标类，这个技巧可以取得很好的效果 标准（完整）转发：NSObject类的子类A可以通过重写NSObject类的forwardInvocation:方法，实现标准转发。标准转发巧可以通过methodSignatureForSelector：方法获取一个methodsignature对象最终被封为NSInvocation对象传递给forwardInvocation:方法（注意如果methodSignatureForSelector：方法返回一个nil，程序会crash）从该对象能获取消息的全部内容（包含目标，方法名，和参数）。 如果你拥有了一个定义了对象能够消化哪些消息的目标类，快速转发可以取得很好的效果。如果你没有这样目标类或想要执行其他处理过程（如记录日志并‘吞下’消息），就应该使用完整转发。 写了一大推字感觉很抽象，下面来点干货下面我要把Test实例的logName消息转发给Target实例，代码如下Test头文件123456789101112131415//// Test.h// ForwardMsg//// Created by 孙磊 on 2017/2/25.// Copyright © 2017年 孙磊. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface Test : NSObject-(void)logName;@end Test实现文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//// Test.m// ForwardMsg//// Created by 孙磊 on 2017/2/25.// Copyright © 2017年 孙磊. All rights reserved.//#import &quot;Test.h&quot;#import &quot;Target.h&quot;#import &lt;objc/runtime.h&gt;@implementation Test&#123; Target *mTarget;&#125;- (instancetype)init&#123; self = [super init]; if (self) &#123; //创建目标对象 mTarget = [Target new]; &#125; return self;&#125;#if 0//当一个对象无法识别消息后，会执行resolveInstanceMethod或者resolveClassMethod方法//如果不想进行消息转发，可以在此方法中动态添加消息来做处理//如果不重写此方法或者此方法返回NO，系统会执行forwardingTargetForSelector进行快速转发+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if(sel == @selector(logName))&#123; //第四个参数详解地址 https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html //v代表返回类型为void //@代表一个对象 //:代表一个selector //因为OC中的每个方法都有默认的两个参数sel 和 selector，所以一般都是v@: class_addMethod([self class],sel,(IMP)dynamicMethodIMP,&quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;//万年备胎void dynamicMethodIMP(id self, SEL _cmd)&#123; //对无法识别的消息做处理 NSLog(@&quot;该对象无法识别 %@ 方法------%s&quot;, NSStringFromSelector(_cmd),__func__);&#125;#else /***************==========1、快速消息转发，快速转发只可以获取到方法签名==========*******************/-(id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@&quot;%s&quot;,__func__); if ([mTarget respondsToSelector:aSelector]) &#123; //目标对象有对应的处理方法，则就会快速消息转发，不会再执行完整消息转发了 return mTarget; &#125; //目标对象也没有对应的方法，此时系统会执行forwardInvocation进行完整消息转发 return nil;&#125;/***********=============2、标准（完整）消息转发，完整消息转发，可以获取方法签名，参数等详细信息==========*********///返回一个完整的方法签名，提供给forwardInvocation以便完整转发消息-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; NSMethodSignature* signature = [super methodSignatureForSelector:aSelector]; if (!signature) signature = [mTarget methodSignatureForSelector:aSelector]; return signature;&#125;-(void)forwardInvocation:(NSInvocation *)anInvocation&#123; NSLog(@&quot;%s-----完整消息转发------&quot;,__func__); SEL invSEL = anInvocation.selector; if ([mTarget respondsToSelector:invSEL])&#123; //利用forwardInvocation方法来重新指定消息处理对象 [anInvocation invokeWithTarget:mTarget]; &#125; else &#123; [self doesNotRecognizeSelector:invSEL]; &#125;&#125;#endif@end 目标文件的头文件123456789101112131415//// Target.h// ForwardMsg//// Created by 孙磊 on 2017/2/25.// Copyright © 2017年 孙磊. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface Target : NSObject-(void)logName;@end 目标文件的实现文件1234567891011121314151617//// Target.m// ForwardMsg//// Created by 孙磊 on 2017/2/25.// Copyright © 2017年 孙磊. All rights reserved.//#import &quot;Target.h&quot;@implementation Target-(void)logName&#123;NSLog(@&quot;我是备用方法---%s&quot;,__func__);&#125;@end 推荐一个国外大大利用消息转发避免后台返回NSNull（后台有时候会返回）而引起的奔溃问题，例如你需要一个字符串他却给你返回了一个“”这样一个NSNull对象。用法很简单，直接把NullSafe.m拖到项目中即可，该文件会在运行时自动加载 扩展：简单说一下NULL，nil，Nil，NSNull的用处NULL：用于普通类型，例如NSIntegernil：用于OC对象（除了类这个对象）,给nil对象发送消息不会crashNil：用于Class类型对象的赋值（类是元类的实例，也是对象）NSNull：用于OC对象的站位，一般会作为集合中的占位元素，给NSNull对象发送消息会crash的，后台给我们返回的就是NSNull对象","categories":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}],"tags":[{"name":"消息转发","slug":"消息转发","permalink":"https://slpowercoder.github.io/tags/消息转发/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}]},{"title":"iOS中assign与weak，retain与strong的区别","slug":"iOS中assign与weak，retain与strong的区别","date":"2017-02-11T15:41:29.000Z","updated":"2017-03-25T05:24:21.000Z","comments":true,"path":"2017/02/11/iOS中assign与weak，retain与strong的区别/","link":"","permalink":"https://slpowercoder.github.io/2017/02/11/iOS中assign与weak，retain与strong的区别/","excerpt":"","text":"以前在没有ARC的时候我们使用assign与retain来修饰属性，后来引入了更安全的weak和strong来修饰属性 assign与weak两者都是弱引用，assign通常用于普通类型属性（如int,NSInteger），还有代理属性的修饰，基本上来说两者是可以通用的。只是后者比前者多了一个功能，后者会在引用的对象被释放的时候将该属性置为nil，而前者依然会指向原来的位置，这样就会变成野指针。在oc中你给你一个nil对象发送消息不会crash，但是给一个对象（野指针）发送他不能解析的消息是会crash的，所以总的来说weak要比assign安全一些。像delegate属性建议用weak修饰而不是assign。 retain和strong他俩都是强引用，除了某些情况下不一样，其他的时候也是可以通用的。 在修饰block属性的时候，相信大家都知道要用copy，如果不copy的话，他的生命周期会随着函数的结束而结束，copy之后会放在堆里面，延长block的生命周期。strong在修饰block的时候就相当于copy，而retain修饰栈block的时候就相当于assign，这样block会出现提前被释放掉的危险。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}],"tags":[{"name":"assign","slug":"assign","permalink":"https://slpowercoder.github.io/tags/assign/"},{"name":"weak","slug":"weak","permalink":"https://slpowercoder.github.io/tags/weak/"},{"name":"retain","slug":"retain","permalink":"https://slpowercoder.github.io/tags/retain/"},{"name":"strong","slug":"strong","permalink":"https://slpowercoder.github.io/tags/strong/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}]},{"title":"iOS中为什么非要用runtime才能在分类中扩展属性呢","slug":"iOS中为什么非要用runtime才能在分类中扩展属性呢","date":"2017-02-11T15:36:36.000Z","updated":"2017-03-13T05:04:04.000Z","comments":true,"path":"2017/02/11/iOS中为什么非要用runtime才能在分类中扩展属性呢/","link":"","permalink":"https://slpowercoder.github.io/2017/02/11/iOS中为什么非要用runtime才能在分类中扩展属性呢/","excerpt":"","text":"想必大家都知道在分类中能扩展属性，而对于能不能扩展属性，能不能扩展成员变量是不是有点模糊，今天元宵节，我就清清嗓子说上两句吧 论点1.分类中是能扩展属性的2.分类是不能给一个类扩展成员变量的 先唠唠嗑强调一下，分类不是类，它只是对类的一个扩展，没有ISA指针，我们知道我们可以通过runtime在不影响原来模块的情况下给模块扩展方法，有没有感觉这一句话好像也可以描述分类，所以你可以认为分类是实现这一功能的捷径，不然你觉得是用分类扩展方法容易还是用runtime来实现容易啊（正值年轻，说话有点冲~_~ !!）。 论据先说说属性，属性是对成员变量的一个封装，当我们声明一个属性的时候，Xcode会给我们默认创建一个 _属性名 的成员变量，也会给我们自动创建getter和setter方法。当然我们也可以用@synthesize指定其关联的变量例如给属性name指定其关联的变量@synthesize name = xxx；self.name其实是操作的实例变量xxx，而不是_name了。窝草，扯远了，回归正传。。所以我们要添加一个属相得有三样东西，setter、getter以及关联的成员变量。在分类中Xcode不会为我们自动创建setter、getter方法，我们可以手动实现，但是如何把一个变量关联到属性上呢，直接声明一个全局变量然后不行吗，事实证明不太行，对于getter方法还好说，直接返回一个变量就行，可是setter方法却不行，因为你要找到该属性关联的变量你才能给人家赋值啊，怎么办？怎么办？？这只能用runtime的对象关联来实现了 123456789101112131415161718192021.m文件中// 定义关联的keystatic const char *key = &quot;name&quot;;@implementation NSObject (Property)- (NSString *)name&#123; // 根据关联的key，获取关联的值。 return objc_getAssociatedObject(self, key);&#125;- (void)setName:(NSString *)name&#123; // 参数一：目标对象 // 参数二：关联的key，可以通过这个key获取 // 参数三：关联的value // 参数四：关联的策略 objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 看到这里你也许就会说，这TMD不是把变量给添加上去了吗？我表示默默一笑，如果你打印IVarList你就会发现并没有这个变量，只能打印出添加的属性。其实对象关联只是关联上去了，并没有把变量添加进去，说了这么多这回你该信了吧。原因就是分类不是类，他没有ISA指针，下面是ISA指针，可以看出他本质上是一个结构体（只是换了个马甲被称之为Class类型，怕你迷糊，再说明白一点，ISA指针就是Class类型），通过ISA指针才能找指向变量的ivars，也就是说你都不知道变量的家，你怎么去给它生猴子啊，但是奇怪了，ISA指针里没有指向属性数组的指针，没有是对的，要不然这一段的解释就废了，可是讲真，属性指针在哪啊？？？有知道的小伙伴请告诉我一下 &gt;_&lt; !!! 1234567891011121314151617struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use Class instead of `struct objc_class *` */ 结论分类中可以给一个对象（类也是对象）添加属性，但是不能添加成员变量，只能关联上去。注意：如果不信，你可以自己再打印一遍吧，会发现只能打印出添加的属性，打印不出变量。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}],"tags":[{"name":"runtime","slug":"runtime","permalink":"https://slpowercoder.github.io/tags/runtime/"},{"name":"category","slug":"category","permalink":"https://slpowercoder.github.io/tags/category/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}]},{"title":"运行react native 官方例子出错的解决办法","slug":"运行react native 官方例子出错","date":"2017-01-07T12:07:16.000Z","updated":"2017-03-13T05:02:05.000Z","comments":true,"path":"2017/01/07/运行react native 官方例子出错/","link":"","permalink":"https://slpowercoder.github.io/2017/01/07/运行react native 官方例子出错/","excerpt":"","text":"学习一样新的东西官网文档和官方源码例子无疑是最好的选择，所以今天clone了官方的例子，100多兆，如果网速不好的话会等待很长时间 ~_~!!，然后直接cd到根目录执行了npm install安装了依赖，可是安装的过程中出错了（也有可能安装成功了，但是运行失败了），估计例子上的版本跟我安装的rn版本不兼容吧。我目前的RN版本是0.39，命令行的版本是react-native-cli:2.0.1 先上官方运行效果图： 解决办法：情况一：如果npm install安装失败的话1、git checkout 0.xx-stable切换到稳定的分支，我切换的是0.41-stable版本，安装运行成功。2、npm install3、找到Examples，里面有四个例子，可以用Xcode打开运行 情况二：npm install 安装成功，但运行失败1、git checkout 0.xx-stable切换到稳定的分支2、fm -rf node_modules &amp;&amp; npm install3、找到Examples，里面有四个例子，可以用Xcode打开运行","categories":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/categories/react-native/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/tags/react-native/"}],"keywords":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/categories/react-native/"}]},{"title":"看了我这篇RN你就入门了","slug":"看了我这篇RN你就入门了","date":"2016-12-30T08:44:51.000Z","updated":"2018-10-10T09:55:25.737Z","comments":true,"path":"2016/12/30/看了我这篇RN你就入门了/","link":"","permalink":"https://slpowercoder.github.io/2016/12/30/看了我这篇RN你就入门了/","excerpt":"","text":"前言React认为每个组件都是一个有限状态机，状态与UI是一一对应的。我们只需管理好APP的state就能控制UI的显示，我们可以在每个component类中来通过this.state和this.setState来管理组件的state，但是如果APP交互比较多比较复杂，或者说该组件的某一状态需要和其他组件共享的话，这种方式就有点复杂了。有没有一种能统一管理APP状态的框架呢，这时候Redux就应用而生了，它是一个用于统一管理APP 所有的state的一个的js框架，它不建议我们在component中直接操作state，而是交给redux的store中进行处理。而react-redux是在react的基础上为移动端定制的状态管理容器。 redux的设计思想（1）Web 应用是一个状态机，视图与状态是一一对应的。（2）所有的状态，保存在一个对象里面，由其统一管理。（3）遵循严格的单项数据流，一个组件所需要的数据，必须由父组件传过来，而不能像flux中直接从store取。（4）状态在组件中是‘只读’的，要交给redux处理 redux概念有图有真相，先来一张redux数据流图，让你有一个整体的把握 action一般是不允许用户直接操作类的state，而是通过触发消息来执行对应的操作来产生一个新的state，用户或后台服务器可以通过store.dispatch(action)来向store发送一个消息（消息至少一个标识该消息的字段type，还可以添加其他字段用于数据传送），store会在内部根据消息的类型type去reducer中执行相应的处理，这个消息我们就叫他为Action，Action本质上是一个JavaScript对象。 实际编码中一般会把整个应用的消息类型统一放在一个文件ActionTypes.js中 1export const ADD_TODO = 'ADD_TODO' Action的结构如下，各个字段的key的名字可以随意命名，但是类型的key一般都是type，数据类型最好为字符串 1234&#123; type: ADD_TODO, text: 'Build my first Redux app'&#125; 随着程序越来越大，你会发现一个组件中的action太多太乱了，所以我们也会把action按业务分类放在各个指定的文件中，但是又有一个问题，若果每个action的字段都有五六个，我们在如下写法岂不是太乱了 1234store.dispatch(&#123; type: ADD_TODO, text: 'Build my first Redux app'&#125;) 于是乎我们就想起来可以将action对象封装在函数中，这个函数返回一个action对象，这个返回一个action对象的函数我们就称之为ActionCreator，如下所示 123456export let todo = ()=&gt; &#123; return &#123; type: ADD_TODO, text: 'Build my first Redux app' &#125;&#125; 我们直接store.dispatch(todo)就好了，看着是不是整洁多了啊 reducer它是一个纯函数，要求有相同的输入（参数）就一定会有相同的输出，它会根据当前的state和action来进行逻辑处理返回一个新的state参数一：当前的state对象参数二：action对象返回值：产生一个新的state对象 1234567891011121314151617import &#123; VisibilityFilters &#125; from './actions'//初始stateconst initialState = &#123; visibilityFilter: VisibilityFilters.SHOW_ALL, todos: []&#125;;function todoApp(state = initialState, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return Object.assign(&#123;&#125;, state, &#123; visibilityFilter: action.filter &#125;) default: return state &#125;&#125; 注意：reducer函数中一定不要去修改state，而是用Object.assign()函数生成一个新的state对象，如上所示 combineReducers：随着应用变得复杂，把APP的所有状态都放在一个reducer中处理会造成reducer函数非常庞大，因此需要对 reducer 函数 进行拆分，拆分后的每一个子reducer独立负责管理 APP state 的一部分。combineReducers 辅助函数的作用是，把多个不同子reducer 函数合并成一个最终的根reducer ，最后将根 reducer 作为createStore的参数就可以创建store对象了。合并后的 reducer 可以调用各个子 reducer，并把它们的结果合并成一个 state 对象。state 对象的结构由传入的多个 reducer 的 key 决定。 最终，state 对象的结构会是这样的： 1234&#123; reducer1: ... reducer2: ...&#125; 使用方法如下所示 12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; combineReducers &#125; from 'redux';import Strolling from './strollingReducer';import Foods from './foodsReducer';import FoodsList from './foodsListReducer';import FoodCompare from './foodCompareReducer';import FoodInfo from './foodInfoReducer';import Search from './searchReducer';import User from './userReducer';export default rootReducer = combineReducers(&#123; Strolling, Foods, FoodsList, FoodCompare, FoodInfo, Search, User,&#125;)// export default rootReducer = combineReducers(&#123;// Strolling:Strolling,// Foods:Foods, // FoodsList:FoodsList,// FoodCompare:FoodCompare,// FoodInfo:FoodInfo,// Search:Search,// User:User,// &#125;) // export default function rootReducer(state = &#123;&#125;,action)&#123;// return&#123;// Strolling: Strolling(state.Strolling,action),// Foods:Foods(state.Foods,action),// FoodsList:FoodsList(state.FoodsList,action),// FoodCompare:FoodCompare(state.FoodCompare,action),// FoodInfo:FoodInfo(state.FoodInfo,action),// Search:Search(state.Search,action),// User:User(state.User,action)// &#125;// &#125;//以上三种方式是等价的,key可以设置也可以省略 注意：我们不一定非要用combineReducers来组合子reducer，我们可以自定义类似功能的方法来组合，state的结构完全由我们决定。 store一个应用只有一个store，store 就是用来维持应用所有的 state 树 的一个对象。 改变 store 内 state 的惟一途径是对它 dispatch 一个 action，它有三个函数 getState() 返回应用当前的 state 树。 dispatch(action) 分发 action。这是触发 state 变化的惟一途径。 会使用当前 getState() 的结果和传入的 action 以同步方式的调用 store 的 reduce 函数。返回值会被作为下一个 state。从现在开始，这就成为了 getState() 的返回值，同时变化监听器(change listener)会被触发。 subscribe(listener) 当state树发生变化的时候store会调用subscribe函数，我们可以传一个我们订制的函数作为参数来进行处理 参数：一个函数 返回值：返回一个解绑定函数 1234//添加监听let unsubscribe = store.subscribe(handleChange)//解除监听unsubscribe() replaceReducer(nextReducer) 替换 store 当前用来计算 state 的 reducer。 这是一个高级 API。只有在你需要实现代码分隔，而且需要立即加载一些 reducer 的时候才可能会用到它。在实现 Redux 热加载机制的时候也可能会用到。 react-redux基础前言已经提到过react-redux的由来，这里在啰嗦一下，react-redux是redux作者专门为react native订制的，这样使用起来更方便，我们只需在我们的组件中通过属性props获取dispatch方法，就可以直接向store发送一个action，而不需要再获取store对象，通过store对象的dispatch方法发送。react-redux有两宝，provider和connect，下面详细介绍一下。 Provider：有一个store属性，我们要将应用的根标签放到Provider标签中，这样应用的所有标签就可以通过context来获取store对象了，但是我们一般不会通过此法来获取store对象，Provider是为了给connect函数使用的，这样才能通过connect函数的参数获取到store的state和dispatch了。 connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])connect是一个高阶函数，connect()本身会返回一个函数变量（假如名字为func），给这个函数变量传递一个参数func(MainContainer)会生成一个MainContainer容器组件，形如下面的写法： 123456export default connect((state) =&gt; &#123; const &#123; Main &#125; = state; return &#123; Main &#125;&#125;)(MainContainer); 参数一：[mapStateToProps(state, [ownProps]): stateProps] (Function) 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。如果你省略了这个参数，你的组件将不会监听 Redux store。如果指定了该回调函数中的第二个参数 ownProps，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，mapStateToProps 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。 参数二：[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。如果传递的是一个函数，该函数将接收一个 dispatch 函数，然后由你来决定如何返回一个对象，这个对象通过 dispatch 函数与 action creator 以某种方式绑定在一起（提示：你也许会用到 Redux 的辅助函数 bindActionCreators()）。如果你省略这个 mapDispatchToProps 参数，默认情况下，dispatch 会注入到你的组件 props 中。如果指定了该回调函数中第二个参数 ownProps，该参数的值为传递到组件的 props，而且只要组件接收到新 props，mapDispatchToProps 也会被调用。 参数三：[mergeProps(stateProps, dispatchProps, ownProps): props] (Function) 如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的 props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。你也许可以用这个回调函数，根据组件的 props 来筛选部分的 state 数据，或者把 props 中的某个特定变量与 action creator 绑定在一起。如果你省略这个参数，默认情况下返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。[options] (Object) 如果指定这个参数，可以定制 connector 的行为。 参数四：[options] (Object) 如果指定这个参数，可以定制 connector 的行为。 [pure = true] (Boolean): 如果为 true，connector 将执行 shouldComponentUpdate 并且浅对比 mergeProps 的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或 state 而只依赖于 props 和 Redux store 的 state。默认值为 true。[withRef = false] (Boolean): 如果为 true，connector 会保存一个对被包装组件实例的引用，该引用通过 getWrappedInstance() 方法获得。默认值为 false。 redux-redux使用上面说了provider和connect方法，下面是实用讲解 创建store对象的js文件 下面的代码里包括应用中间件redux-thunk，和创建store对象两步，这里有更多关于中间件的详情 12345678import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;import rootReducer from &apos;../reducers/rootRudcer&apos;;//使用thunk中间件let createStoreWithMiddleware = applyMiddleware(thunk)(createStore);//创建store对象，一个APP只有一个store对象let store = createStoreWithMiddleware(rootReducer);export default store; 程序的入口文件 12345678910111213141516import React from &apos;react&apos;;import &#123; Provider &#125; from &apos;react-redux&apos;;import store from &apos;./store/store&apos;;import App from &apos;./containers/app&apos;;export default class Root extends React.Component &#123; render() &#123; return ( //将APP的根视图组件包含在provider标签中 &lt;Provider store = &#123;store&#125; &gt; &lt;App /&gt; &lt;/Provider&gt; ) &#125;&#125; 在容器组件中，将redux和容器组件关联起来，这里是redux与组件关联的地方，大多数童鞋使用redux最迷惑的地方估计就在这一块了。 123456789101112131415161718192021import React from &apos;react&apos;;import &#123;connect&#125; from &apos;react-redux&apos;;import Brand from &apos;../Components/Brand&apos;;//BrandContainer容器组件class BrandContainer extends React.Component &#123; render() &#123; return ( //把容器组件的属性传递给UI组件 &lt;Brand &#123;...this.props&#125; /&gt; ) &#125;&#125;export default connect((state) =&gt; &#123; const &#123; BrandReducer &#125; = state; return &#123; BrandReducer &#125;&#125;)(BrandContainer); 这样UI组件Brand中就可以通过属性获取dispatch方法以及处理后的最新state了 1const &#123;dispatch, BrandReducer&#125; = this.props; 下面来解释一下上面的代码 将当前的BrandContainer组件关联起来，上面介绍了store中的state对象的结构会是这样的： { reducer1: … reducer2: …} 所以可以通过解构的方式，获取对应模块的state，如下面的const { BrandReducer } = state; 下面这一块代码的作用就是将store中state传递给关联的容器组件中，当store中的state发生变化的时候，connect的第一参数mapStateToProps回调函数就会被调用，并且将该回调函数的返回值映射成其关联组件的一个属性，这样容器组件的属性就会发生变化，而UI组件又通过{…this.props}将容器组件的属性传递给了UI组件，所以UI组件的属性也会发生变化，我们知道属性的变化会导致UI组件重新render。好了，我们就能知道为什么我们在UI组件中dispatch一个action后UI组件能更新了，因为UI组件的属性发生变化导致RN重绘了UI。 react native 组件的生命周期弄明白了这个图我认为你就能基本掌握RN了注意：上图的最右边componentWillMount改成componentWillUnmount 项目的推荐目录这种结构适合业务逻辑不太复杂的中小型项目，其优点是逻辑模块清晰，缺点是文件目录跨度较大，对于大型项目建议按项目的功能模块来划分。 热更新暂时不说了，苹果粑粑这两天不高兴了，凡是热更新的APP不能上架，已上线的APP也应该收到了一份批评邮件了。 相关文章React 实践心得：react-redux 之 connect 方法详解Redux 入门教程（一）：基本用法redux中文文档 注：部分图片来源于互联网 原文链接，转载请注明此链接","categories":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/categories/react-native/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/tags/react-native/"},{"name":"redux","slug":"redux","permalink":"https://slpowercoder.github.io/tags/redux/"},{"name":"react-redux","slug":"react-redux","permalink":"https://slpowercoder.github.io/tags/react-redux/"}],"keywords":[{"name":"react-native","slug":"react-native","permalink":"https://slpowercoder.github.io/categories/react-native/"}]},{"title":"iOS小知识","slug":"iOS你可能不知道的小技巧","date":"2016-09-02T09:48:56.000Z","updated":"2017-03-13T05:03:12.000Z","comments":true,"path":"2016/09/02/iOS你可能不知道的小技巧/","link":"","permalink":"https://slpowercoder.github.io/2016/09/02/iOS你可能不知道的小技巧/","excerpt":"","text":"原文https://slpowercoder.github.io/ 去掉按钮的高亮黑 1[funcImgBtn setAdjustsImageWhenHighlighted:NO]; 设置视图属性防止背景图片变形关于UIViewContentMode的详解http://blog.csdn.net/iunion/article/details/7494511 12345//对于UIButton需要设置button中的imageView的contentMode属性button.imageView.contentMode = UIViewContentModeScaleAspectFill;//视图.contentMode = UIViewContentModeScaleAspectFill;视图.clipsToBounds = YES; 当一个页面有多个scrollView（或继承自scrollVIew）的时候，点击状态栏不会回到顶部，可以将非当前显示页的scrollVIew. scrollToTop设置为NO。 去掉在UITableViewStylePlain 样式的时候多余的默认cell 1_tableView.tableFooterView = [[UIView alloc]init]; 去掉在UITableViewStyleGrouped 样式的时候默认的组脚高度 123-(CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section&#123;return 0.001; //越小越好，不能设置为0&#125; 自定义导航栏的返回按钮而造成返回手势的失效的解决办法，对于最顶层的VC我们需要设置enabled = NO，因为最外面一层是不需要该手势的 12self.navigationController.interactivePopGestureRecognizer.delegate = self;self.navigationController.interactivePopGestureRecognizer.enabled = YES; 根据十六进制色值返回一个UIColor对象的宏 1#define USERCOLOR(string) [UIColor colorWithRed:((float)((string &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((string &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(string &amp; 0xFF))/255.0 alpha:1.0] 控制屏幕是否锁屏 12//值为yes的时候可以防止屏幕黑屏，注意在程序结束点时候要设置为no[[UIApplication sharedApplication] setIdleTimerDisabled:YES]; 防止自定义导航栏返回按钮时，返回手势失效 1self.navigationController.interactivePopGestureRecognizer.enabled = YES; 打印函数，可以打印所在的函数，行数，以及你要打印的值 1#define DLog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__); UISwitch的大小直接设置frame是没有用的，可以通过CGAffineTransformMakeScale缩放来设置 load和initialize 1234//程序在加载类文件时候会调用load，无论实现该方法的类有没有被引用（只要程序运行的时候就会加载该类文件）+(void)load//在类被初始化之前会调用一次+(void)initialize iPad使用UIAlertController会crashhttp://stackoverflow.com/questions/31577140/uialertcontroller-is-crashed-ipad","categories":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://slpowercoder.github.io/categories/iOS/"}]},{"title":"Mac上 Hexo安装与配置","slug":"hexo的安装和配置","date":"2016-09-01T16:03:34.000Z","updated":"2018-06-26T14:15:24.756Z","comments":true,"path":"2016/09/02/hexo的安装和配置/","link":"","permalink":"https://slpowercoder.github.io/2016/09/02/hexo的安装和配置/","excerpt":"","text":"安装1. 安装node.js传送下载node的pkg包，点击直接安装，安装的过程下一步下一步就行了，新版的node.js包含有npm（npm用来安装hexo） 2. 安装hexo1$ sudo npm install -g hexo-cli 注意：如果没有用sudo来执行命令可能会出现错误 3. 建立本地站点现在本地创建一个文件夹，作为本地站点的根目录，例如建立一个HexoBlog文件夹，cd到HexoBlog的上一级目录执行以下命令 1.初始化一个本地站点 1hexo init HexoBlog 2.进入站点根目录然后进行安装本地站点 1cd HexoBlog 1npm install 3.生成静态页面 1hexo g 4.启动本地站点服务器查看效果，执行本命令之后会提示出一个URL，将URL放入浏览器查看效果，按Ctrl+c关闭本地站点服务器 1hexo server 配置1. 基本配置1.在github上创建一个仓库，仓库的名字必须为”github用户名.github.io” 2.如果你使用过github，我猜你已经配置好了SSH key,这里我就不多说了，不过即使没有配置SSH key也没关系，只是以后每次提交的时候会提示要求输入密码 3.修改站点_config.xml文件，如下： 123456# Deployment# Docs: https://hexo.io/docs/deployment.htmldeploy: type: git #部署类型, 本文使用Git，发现使用github+SSH的方式会提示找不到github repository: https://github.com/SLPowerCoder/SLPowerCoder.github.io #部署的仓库url,发现使用github+SSH的方式会提示找不到github branch: master #部署分支,一般使用master主分支 4.这些基本的配置完成之后就可以执行命令部署到github上了 执行下面的命令，安装git部署插件，不然执行了 hexo deploy之后会没有反应，也没有任何提示部署失败，其实是失败的 1$ npm install hexo-deployer-git --save 5.执行下面命令，用于生成静态文件并部署到远程站点，你也可以分两步写 1$ hexo g -d 上述然后在浏览器中输入 github用户名.github.io就可浏览了 2. 博客主题配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 枫叶subtitle: 枫叶description: 坐看云起时author: 枫叶language: zh-Hans timezone:email: sunlei_1030@126.com # 邮箱# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://slpowercoder.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Disqus disqus评论, 与多说类似, 国内一般使用多说# disqus_shortname: duoshuo_shortname: fengye1030 # 这里添加多说评论# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yelee #默认是landscape 还有yelee,yilia等等# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git #部署类型, 本文使用Git，发现使用github+SSH的方式会提示找不到github repository: https://github.com/SLPowerCoder/SLPowerCoder.github.io #部署的仓库url,采用https的,发现使用github+SSH的方式会提示找不到github branch: master #部署分支,一般使用master主分支 hexo的使用（下面的命令如果报错，请用sudo权限执行）1.创建文章（也可以把创建好的md文件直接放到根目录source/_posts目录中） 1$ hexo new \"My New Post\" 2.清楚缓存的静态页面 1$ hexo clean 3.生成静态页面 1$ hexo generate 4.运行本地服务器查看效果 1$ hexo server 5.部署到远程站点 1$ hexo deploy 参考文献hexo官网","categories":[{"name":"hexo","slug":"hexo","permalink":"https://slpowercoder.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://slpowercoder.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://slpowercoder.github.io/tags/博客/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"https://slpowercoder.github.io/categories/hexo/"}]}]}